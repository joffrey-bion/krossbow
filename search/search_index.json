{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Krossbow is a Kotlin multiplatform STOMP 1.2 client with a coroutine-based API. It is built on a web socket client abstraction, and provides a bunch of adapters for popular web socket clients (OkHttp, Ktor, Spring, SockJS...). It also provides out-of-the-box a built-in web socket implementation (without third-party dependencies) for most platforms (see below). Krossbow can also be used as a multiplatform web socket client without STOMP protocol. Features \u00b6 All of the STOMP 1.2 specification is implemented: All STOMP frames, including ACK / NACK and transactions Text and binary bodies Receipts (waiting for RECEIPT frame based on receipt header) Heart beats (keep alive) Custom headers where the protocol allows them Additional features: Auto-receipts (automatically adds receipt headers to ensure no frame is lost) Built-in body conversions (Kotlinx Serialization or Jackson) Possibility to hook custom body converters (for textual or binary bodies) Automatic content length header for sent frames If you find a bug or a feature that's missing compared to the specification, please open an issue . Supported targets \u00b6 Krossbow supports the following targets: JVM JS (browser & NodeJS) Android (using JVM artifacts) iOS, watchOS, tvOS Native Desktop The desktop Native targets are currently unsupported, due to a lack of native web socket implementations. Contributions are of course welcome! Android not tested on CI Android 5.0+ (API level 21+) is supported by using JVM artifacts (e.g. OkHttp). However, the Android tooling's desugaring is currently not tested as part of the build, so any feedback on this use case is more than welcome. Please upvote the corresponding issue if you'd like to see proper CI or special packaging for the Android target. Web socket clients target support \u00b6 Krossbow can use built-in web socket implementations without third-party dependencies on some platforms. It also provides adapters for third-party implementations which have different platform support. Here is a summary of the supported platform by module: Web Socket Module Browser NodeJS JVM8+ (blocking) JVM11+ (async) iOS / tvOS / watchOS Transitive dependencies Core (built-in) None Ktor * Ktor , and the relevant Ktor engine(s) OkHttp OkHttp SockJS sockjs-client (on JS), Spring websocket (on JVM) Spring Spring websocket supported with actual web socket transport (RFC6455) supported using SockJS protocol (requires a SockJS server) * backed by blocking I/O when using the OkHttp engine, but can be fully non-blocking with the CIO engine Contribute \u00b6 Don't hesitate to open GitHub issues , even to ask questions or discuss a new feature. Pull-requests are welcome, but please open an issue first so that we can discuss the initial design or fix, which may avoid unnecessary work.","title":"Overview"},{"location":"#features","text":"All of the STOMP 1.2 specification is implemented: All STOMP frames, including ACK / NACK and transactions Text and binary bodies Receipts (waiting for RECEIPT frame based on receipt header) Heart beats (keep alive) Custom headers where the protocol allows them Additional features: Auto-receipts (automatically adds receipt headers to ensure no frame is lost) Built-in body conversions (Kotlinx Serialization or Jackson) Possibility to hook custom body converters (for textual or binary bodies) Automatic content length header for sent frames If you find a bug or a feature that's missing compared to the specification, please open an issue .","title":"Features"},{"location":"#supported-targets","text":"Krossbow supports the following targets: JVM JS (browser & NodeJS) Android (using JVM artifacts) iOS, watchOS, tvOS Native Desktop The desktop Native targets are currently unsupported, due to a lack of native web socket implementations. Contributions are of course welcome! Android not tested on CI Android 5.0+ (API level 21+) is supported by using JVM artifacts (e.g. OkHttp). However, the Android tooling's desugaring is currently not tested as part of the build, so any feedback on this use case is more than welcome. Please upvote the corresponding issue if you'd like to see proper CI or special packaging for the Android target.","title":"Supported targets"},{"location":"#web-socket-clients-target-support","text":"Krossbow can use built-in web socket implementations without third-party dependencies on some platforms. It also provides adapters for third-party implementations which have different platform support. Here is a summary of the supported platform by module: Web Socket Module Browser NodeJS JVM8+ (blocking) JVM11+ (async) iOS / tvOS / watchOS Transitive dependencies Core (built-in) None Ktor * Ktor , and the relevant Ktor engine(s) OkHttp OkHttp SockJS sockjs-client (on JS), Spring websocket (on JVM) Spring Spring websocket supported with actual web socket transport (RFC6455) supported using SockJS protocol (requires a SockJS server) * backed by blocking I/O when using the OkHttp engine, but can be fully non-blocking with the CIO engine","title":"Web socket clients target support"},{"location":"#contribute","text":"Don't hesitate to open GitHub issues , even to ask questions or discuss a new feature. Pull-requests are welcome, but please open an issue first so that we can discuss the initial design or fix, which may avoid unnecessary work.","title":"Contribute"},{"location":"artifacts/","text":"Krossbow offers a lot of possibilities so here is a summary of all available artifacts. All these artifacts are published to Maven Central under the group ID org.hildan.krossbow and a common version. STOMP artifacts \u00b6 You should pick only one of the krossbow-stomp-* artifacts, depending on whether you need automatic serialization of frame bodies: Artifact Description krossbow-stomp-core The basic multiplatform STOMP client. It implements the STOMP 1.2 protocol on top of the web socket abstraction defined by the krossbow-websocket-core module. krossbow-stomp-jackson A superset of krossbow-stomp-core adding JSON conversion features using Jackson (JVM only) krossbow-stomp-kxserialization A superset of krossbow-stomp-core adding conversion features using Kotlinx Serialization library (multiplatform). You can leverage the multi-format capabilities of Kotlinx Serialization (JSON, protobuf, CBOR, ...). Then add the dependency of your choice to your Gradle build. For instance, if you intend to use Krossbow with Kotlinx Serialization: implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:3.3.1\" ) Don't need STOMP? If you're just interested in the web socket client without STOMP protocol, don't declare a STOMP artifact, but instead choose either: the built-in Core web socket implementation (without third-party dependencies) a third party web socket implementation (see below) Third party web socket adapters \u00b6 The STOMP artifacts come with the built-in web socket client for each platform, so no additional dependency is required. However, if you want a different web socket implementation, you can pick from the other web socket adapters and add the relevant artifact: Artifact Description krossbow-websocket-ktor A multiplatform WebSocketClient implementation based on Ktor's HttpClient . krossbow-websocket-okhttp a JVM implementation of the web socket API using OkHttp's krossbow-websocket-sockjs a multiplatform WebSocketClient implementation for use with SockJS servers. It uses Spring's SockJSClient on JVM, and npm sockjs-client for JavaScript (NodeJS and browser). krossbow-websocket-spring a JVM 8+ implementation of the web socket API using Spring's WebSocketClient. Provides both a normal WebSocket client and a SockJS one. Peer dependencies Some Krossbow modules are not opinionated and require some extra third-party peer dependencies. Make sure to read the usage section corresponding to the module of your choice for more details.","title":"Artifacts summary"},{"location":"artifacts/#stomp-artifacts","text":"You should pick only one of the krossbow-stomp-* artifacts, depending on whether you need automatic serialization of frame bodies: Artifact Description krossbow-stomp-core The basic multiplatform STOMP client. It implements the STOMP 1.2 protocol on top of the web socket abstraction defined by the krossbow-websocket-core module. krossbow-stomp-jackson A superset of krossbow-stomp-core adding JSON conversion features using Jackson (JVM only) krossbow-stomp-kxserialization A superset of krossbow-stomp-core adding conversion features using Kotlinx Serialization library (multiplatform). You can leverage the multi-format capabilities of Kotlinx Serialization (JSON, protobuf, CBOR, ...). Then add the dependency of your choice to your Gradle build. For instance, if you intend to use Krossbow with Kotlinx Serialization: implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:3.3.1\" ) Don't need STOMP? If you're just interested in the web socket client without STOMP protocol, don't declare a STOMP artifact, but instead choose either: the built-in Core web socket implementation (without third-party dependencies) a third party web socket implementation (see below)","title":"STOMP artifacts"},{"location":"artifacts/#third-party-web-socket-adapters","text":"The STOMP artifacts come with the built-in web socket client for each platform, so no additional dependency is required. However, if you want a different web socket implementation, you can pick from the other web socket adapters and add the relevant artifact: Artifact Description krossbow-websocket-ktor A multiplatform WebSocketClient implementation based on Ktor's HttpClient . krossbow-websocket-okhttp a JVM implementation of the web socket API using OkHttp's krossbow-websocket-sockjs a multiplatform WebSocketClient implementation for use with SockJS servers. It uses Spring's SockJSClient on JVM, and npm sockjs-client for JavaScript (NodeJS and browser). krossbow-websocket-spring a JVM 8+ implementation of the web socket API using Spring's WebSocketClient. Provides both a normal WebSocket client and a SockJS one. Peer dependencies Some Krossbow modules are not opinionated and require some extra third-party peer dependencies. Make sure to read the usage section corresponding to the module of your choice for more details.","title":"Third party web socket adapters"},{"location":"license/","text":"MIT License \u00b6 Copyright (c) 2019-2021 Joffrey Bion Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#mit-license","text":"Copyright (c) 2019-2021 Joffrey Bion Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"stomp/advanced-features/","text":"Receipts & Suspension \u00b6 The STOMP protocol supports RECEIPT frames, allowing the client to know when the server has received a frame. This only happens if a receipt header is set on the client frame. If auto-receipt is enabled, a receipt header is automatically generated and added to all client frames supporting the mechanism, and for which a receipt header is not already present. If auto-receipt is not enabled, a receipt header may still be provided manually in the parameters of some overloads. When a receipt header is present (automatically added or manually provided), the method that is used to send the frame suspends until the corresponding RECEIPT frame is received from the server. If no RECEIPT frame is received from the server in the configured time limit , a LostReceiptException is thrown. If no receipt is provided and auto-receipt is disabled, the method used to send the frame doesn't wait for a RECEIPT frame and never throws LostReceiptException . Instead, it returns immediately after the underlying web socket implementation is done sending the frame. Heart beats \u00b6 When configured, heart beats can be used as a keep-alive to detect if the connection is lost. The heartBeat property should be used to configure heart beats in the StompClient . Note that the heart beats for the STOMP session are negotiated with the server. The actual heart beats are defined by the CONNECTED frame received from the server as a result of the negotiation, and may differ from the StompClient configuration. The negotiation behaviour is defined by the specification . Sending and checking heart beats is automatically handled by StompSession implementations, depending on the result of the negotiation with the server. If expected heart beats are not received in time, a MissingHeartBeatException is thrown and fails active subscriptions. Graceful disconnect \u00b6 The graceful disconnect (or graceful shutdown) is a disconnection procedure defined by the STOMP specification to make sure the server gets all the frames before dropping the connection. If enabled in the config , when disconnecting from the server, the client first sends a DISCONNECT frame with a receipt header, and then waits for a RECEIPT frame before closing the connection. If this graceful disconnect is disabled, then calling StompSession.disconnect() immediately closes the web socket connection. In this case, there is no guarantee that the server received all previous messages.","title":"Advanced features"},{"location":"stomp/advanced-features/#receipts-suspension","text":"The STOMP protocol supports RECEIPT frames, allowing the client to know when the server has received a frame. This only happens if a receipt header is set on the client frame. If auto-receipt is enabled, a receipt header is automatically generated and added to all client frames supporting the mechanism, and for which a receipt header is not already present. If auto-receipt is not enabled, a receipt header may still be provided manually in the parameters of some overloads. When a receipt header is present (automatically added or manually provided), the method that is used to send the frame suspends until the corresponding RECEIPT frame is received from the server. If no RECEIPT frame is received from the server in the configured time limit , a LostReceiptException is thrown. If no receipt is provided and auto-receipt is disabled, the method used to send the frame doesn't wait for a RECEIPT frame and never throws LostReceiptException . Instead, it returns immediately after the underlying web socket implementation is done sending the frame.","title":"Receipts &amp; Suspension"},{"location":"stomp/advanced-features/#heart-beats","text":"When configured, heart beats can be used as a keep-alive to detect if the connection is lost. The heartBeat property should be used to configure heart beats in the StompClient . Note that the heart beats for the STOMP session are negotiated with the server. The actual heart beats are defined by the CONNECTED frame received from the server as a result of the negotiation, and may differ from the StompClient configuration. The negotiation behaviour is defined by the specification . Sending and checking heart beats is automatically handled by StompSession implementations, depending on the result of the negotiation with the server. If expected heart beats are not received in time, a MissingHeartBeatException is thrown and fails active subscriptions.","title":"Heart beats"},{"location":"stomp/advanced-features/#graceful-disconnect","text":"The graceful disconnect (or graceful shutdown) is a disconnection procedure defined by the STOMP specification to make sure the server gets all the frames before dropping the connection. If enabled in the config , when disconnecting from the server, the client first sends a DISCONNECT frame with a receipt header, and then waits for a RECEIPT frame before closing the connection. If this graceful disconnect is disabled, then calling StompSession.disconnect() immediately closes the web socket connection. In this case, there is no guarantee that the server received all previous messages.","title":"Graceful disconnect"},{"location":"stomp/basics/","text":"Gradle dependency \u00b6 For the basic usage of STOMP without body conversions, you only need the following Gradle dependency: implementation ( \"org.hildan.krossbow:krossbow-stomp-core:3.3.1\" ) You need to replace it if you want to use serialization/deserialization features ( see below ). Basic usage (without body conversions) \u00b6 This is how to create a STOMP client and interact with it: import kotlinx.coroutines.flow.* import org.hildan.krossbow.stomp.* val client = StompClient () // custom WebSocketClient and other config can be passed in here val session : StompSession = client . connect ( url ) // optional login/passcode can be provided here session . sendText ( \"/some/destination\" , \"Basic text message\" ) // this triggers a SUBSCRIBE frame and returns the flow of messages for the subscription val subscription : Flow < String > = session . subscribeText ( \"/some/topic/destination\" ) val collectorJob = launch { subscription . collect { msg -> println ( \"Received: $ msg \" ) } } delay ( 3000 ) // cancelling the flow collector triggers an UNSUBSCRIBE frame collectorJob . cancel () session . disconnect () If you want to disconnect automatically in case of exception or normal termination, you can use a try / finally block, or use StompSession.use() , which is similar to Closeable.use() : import kotlinx.coroutines.flow.* import org.hildan.krossbow.stomp.* val client = StompClient () // custom WebSocketClient and other config can be passed in here val session : StompSession = client . connect ( url ) // optional login/passcode can be provided here session . use { s -> s . sendText ( \"/some/destination\" , \"Basic text message\" ) val subscription : Flow < String > = s . subscribeText ( \"/some/topic/destination\" ) // terminal operators that finish early (like first) also trigger UNSUBSCRIBE automatically val firstMessage : String = subscription . first () println ( \"Received: $ firstMessage \" ) } // DISCONNECT frame was automatically sent at the end of the use{...} block Using body conversions \u00b6 You can use STOMP with basic text as frame bodies, but it really becomes interesting when you can convert the frame bodies back and forth into Kotlin objects. Check out the following sections to see how to automatically convert your objects into STOMP frame bodies: using Kotlinx Serialization (multiplatform) using Jackson (JVM-only) using custom conversions","title":"Basic usage"},{"location":"stomp/basics/#gradle-dependency","text":"For the basic usage of STOMP without body conversions, you only need the following Gradle dependency: implementation ( \"org.hildan.krossbow:krossbow-stomp-core:3.3.1\" ) You need to replace it if you want to use serialization/deserialization features ( see below ).","title":"Gradle dependency"},{"location":"stomp/basics/#basic-usage-without-body-conversions","text":"This is how to create a STOMP client and interact with it: import kotlinx.coroutines.flow.* import org.hildan.krossbow.stomp.* val client = StompClient () // custom WebSocketClient and other config can be passed in here val session : StompSession = client . connect ( url ) // optional login/passcode can be provided here session . sendText ( \"/some/destination\" , \"Basic text message\" ) // this triggers a SUBSCRIBE frame and returns the flow of messages for the subscription val subscription : Flow < String > = session . subscribeText ( \"/some/topic/destination\" ) val collectorJob = launch { subscription . collect { msg -> println ( \"Received: $ msg \" ) } } delay ( 3000 ) // cancelling the flow collector triggers an UNSUBSCRIBE frame collectorJob . cancel () session . disconnect () If you want to disconnect automatically in case of exception or normal termination, you can use a try / finally block, or use StompSession.use() , which is similar to Closeable.use() : import kotlinx.coroutines.flow.* import org.hildan.krossbow.stomp.* val client = StompClient () // custom WebSocketClient and other config can be passed in here val session : StompSession = client . connect ( url ) // optional login/passcode can be provided here session . use { s -> s . sendText ( \"/some/destination\" , \"Basic text message\" ) val subscription : Flow < String > = s . subscribeText ( \"/some/topic/destination\" ) // terminal operators that finish early (like first) also trigger UNSUBSCRIBE automatically val firstMessage : String = subscription . first () println ( \"Received: $ firstMessage \" ) } // DISCONNECT frame was automatically sent at the end of the use{...} block","title":"Basic usage (without body conversions)"},{"location":"stomp/basics/#using-body-conversions","text":"You can use STOMP with basic text as frame bodies, but it really becomes interesting when you can convert the frame bodies back and forth into Kotlin objects. Check out the following sections to see how to automatically convert your objects into STOMP frame bodies: using Kotlinx Serialization (multiplatform) using Jackson (JVM-only) using custom conversions","title":"Using body conversions"},{"location":"stomp/config/","text":"Configuring the StompClient \u00b6 The StompClient can be configured at construction time using a convenient lambda block: val stompClient = StompClient { connectionTimeout = 3000 gracefulDisconnect = false } You can also create the configuration separately and then pass it when constructing the client: val stompConfig = StompConfig (). apply { connectionTimeout = 3000 gracefulDisconnect = false } val stompClient = StompClient ( config = stompConfig ) Configuration options \u00b6 autoReceipt (default: false) Whether to automatically attach a receipt header to the sent frames in order to track receipts. autoContentLength (default: true) Whether to automatically compute and add the content-length header in sent frames. connectWithStompCommand (default: false) Whether to use the STOMP command instead of CONNECT to establish the connection. Clients that use the STOMP frame instead of the CONNECT frame will only be able to connect to STOMP 1.2 servers (as well as some STOMP 1.1 servers) but the advantage is that a protocol sniffer/discriminator will be able to differentiate the STOMP connection from an HTTP connection. heartBeat (default: none) The heart beats to request for the STOMP sessions. This is part of a negotiation and does not imply that this exact heart beat configuration will be used. The actual heart beats are defined by the CONNECTED frame received from the server as a result of the negotiation. This behaviour is defined by the specification . heartBeatTolerance (default: none) Defines tolerance for heart beats. If both the client and server really stick to the heart beats periods negotiated and given by the CONNECTED frame, network latencies will make them miss their marks. That's why we need some sort of tolerance. In case the server is too strict about its expectations, we can send heart beats a little bit earlier than we're supposed to (see HeartBeatTolerance.outgoingMargin ). In case the server really sticks to its own period without such margin, we need to allow a little bit of delay to make up for network latencies before we fail and close the connection (see HeartBeatTolerance.incomingMargin ). connectionTimeout (default: 15s) Defines how long to wait for the websocket+STOMP connection to be established before throwing an exception. receiptTimeout (default: 1s) Defines how long to wait for a RECEIPT frame from the server before throwing a LostReceiptException . Only crashes when a receipt header was actually present in the sent frame (and thus a RECEIPT was expected). Such header is always present if autoReceipt is enabled. Note that this doesn't apply to the DISCONNECT frames, use disconnectTimeout instead for that. disconnectTimeout (default: 200ms) Like receiptTimeout but only for the receipt of the DISCONNECT frame. This is ignored if gracefulDisconnect is disabled. Note that if this timeout expires, the [StompSession.disconnect] call doesn't throw an exception. This is to allow servers to close the connection quickly (sometimes too quick for sending a RECEIPT/ERROR) as mentioned in the specification . gracefulDisconnect (default: true) Enables graceful disconnect . If enabled, when disconnecting from the server, the client first sends a DISCONNECT frame with a receipt header, and then waits for a RECEIPT frame before closing the connection. If this graceful disconnect is disabled, then calling [StompSession.disconnect] immediately closes the web socket connection. In this case, there is no guarantee that the server received all previous messages. instrumentation A set of hooks that are called in different places of the internal execution of Krossbow. The instrumentation can be used for monitoring, logging or debugging purposes.","title":"Configuration"},{"location":"stomp/config/#configuring-the-stompclient","text":"The StompClient can be configured at construction time using a convenient lambda block: val stompClient = StompClient { connectionTimeout = 3000 gracefulDisconnect = false } You can also create the configuration separately and then pass it when constructing the client: val stompConfig = StompConfig (). apply { connectionTimeout = 3000 gracefulDisconnect = false } val stompClient = StompClient ( config = stompConfig )","title":"Configuring the StompClient"},{"location":"stomp/config/#configuration-options","text":"autoReceipt (default: false) Whether to automatically attach a receipt header to the sent frames in order to track receipts. autoContentLength (default: true) Whether to automatically compute and add the content-length header in sent frames. connectWithStompCommand (default: false) Whether to use the STOMP command instead of CONNECT to establish the connection. Clients that use the STOMP frame instead of the CONNECT frame will only be able to connect to STOMP 1.2 servers (as well as some STOMP 1.1 servers) but the advantage is that a protocol sniffer/discriminator will be able to differentiate the STOMP connection from an HTTP connection. heartBeat (default: none) The heart beats to request for the STOMP sessions. This is part of a negotiation and does not imply that this exact heart beat configuration will be used. The actual heart beats are defined by the CONNECTED frame received from the server as a result of the negotiation. This behaviour is defined by the specification . heartBeatTolerance (default: none) Defines tolerance for heart beats. If both the client and server really stick to the heart beats periods negotiated and given by the CONNECTED frame, network latencies will make them miss their marks. That's why we need some sort of tolerance. In case the server is too strict about its expectations, we can send heart beats a little bit earlier than we're supposed to (see HeartBeatTolerance.outgoingMargin ). In case the server really sticks to its own period without such margin, we need to allow a little bit of delay to make up for network latencies before we fail and close the connection (see HeartBeatTolerance.incomingMargin ). connectionTimeout (default: 15s) Defines how long to wait for the websocket+STOMP connection to be established before throwing an exception. receiptTimeout (default: 1s) Defines how long to wait for a RECEIPT frame from the server before throwing a LostReceiptException . Only crashes when a receipt header was actually present in the sent frame (and thus a RECEIPT was expected). Such header is always present if autoReceipt is enabled. Note that this doesn't apply to the DISCONNECT frames, use disconnectTimeout instead for that. disconnectTimeout (default: 200ms) Like receiptTimeout but only for the receipt of the DISCONNECT frame. This is ignored if gracefulDisconnect is disabled. Note that if this timeout expires, the [StompSession.disconnect] call doesn't throw an exception. This is to allow servers to close the connection quickly (sometimes too quick for sending a RECEIPT/ERROR) as mentioned in the specification . gracefulDisconnect (default: true) Enables graceful disconnect . If enabled, when disconnecting from the server, the client first sends a DISCONNECT frame with a receipt header, and then waits for a RECEIPT frame before closing the connection. If this graceful disconnect is disabled, then calling [StompSession.disconnect] immediately closes the web socket connection. In this case, there is no guarantee that the server received all previous messages. instrumentation A set of hooks that are called in different places of the internal execution of Krossbow. The instrumentation can be used for monitoring, logging or debugging purposes.","title":"Configuration options"},{"location":"stomp/conversions/custom/","text":"If you want to use your own text conversion, you can implement TextMessageConverter without any additional module, and use withTextConversions to wrap your StompSession into a StompSessionWithClassToTextConversions . Limited JS support Reflection-based conversions are very likely to behave poorly on the JS platform. It is usually safer to rely on Kotlinx Serialization for multiplatform conversions. val myConverter = object : TextMessageConverter { override val mimeType : String = \"application/json;charset=utf-8\" override fun < T : Any > convertToString ( body : T , bodyType : KClass < T > ): String { TODO ( \"your own object -> text conversion\" ) } override fun < T : Any > convertFromString ( body : String , bodyType : KClass < T > ): T { TODO ( \"your own text -> object conversion\" ) } } StompClient (). connect ( url ). withTextConversions ( myConverter ). use { session -> session . convertAndSend ( \"/some/destination\" , MyPojo ( \"Custom\" , 42 )) val messages = session . subscribe < MyMessage > ( \"/some/topic/destination\" ) val firstMessage : MyMessage = messages . first () println ( \"Received: $ firstMessage \" ) }","title":"Custom conversions"},{"location":"stomp/conversions/jackson/","text":"STOMP with Jackson \u00b6 The krossbow-stomp-jackson module is a JVM-only extension of krossbow-stomp-core that provides new APIs to send and receive properly typed classes, and automatically convert them to/from the JSON bodies of STOMP frames by leveraging Jackson and jackson-module-kotlin . The main addition is the extension function StompSession.withJacksonConversions() , which turns your StompSession into a StompSessionWithClassConversions . This new session type has additional methods that use reflection to convert your objects into JSON and back: StompClient (). connect ( url ). withJacksonConversions (). use { session -> session . convertAndSend ( \"/some/destination\" , Person ( \"Bob\" , 42 )) val messages : Flow < MyMessage > = session . subscribe < MyMessage > ( \"/some/topic/destination\" ) val firstMessage : MyMessage = messages . first () println ( \"Received: $ firstMessage \" ) } Using a custom ObjectMapper \u00b6 Jackson is highly configurable, and it's often useful to configure the ObjectMapper manually. The withJacksonConversions() method takes an optional ObjectMapper parameter, so you can configure it as you please: val customObjectMapper : ObjectMapper = jacksonObjectMapper () . disable ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) . disable ( DeserializationFeature . FAIL_ON_IGNORED_PROPERTIES ) . enable ( SerializationFeature . ORDER_MAP_ENTRIES_BY_KEYS ) val client = StompClient (). connect ( url ) val session = client . withJacksonConversions ( customObjectMapper ) Dependency \u00b6 You will need to declare the following Gradle dependency to add these capabilities (you don't need the core module anymore as it is transitively brought by this one): implementation ( \"org.hildan.krossbow:krossbow-stomp-jackson:3.3.1\" ) This dependency transitively brings Jackson 2.13.2 with the Kotlin module .","title":"Jackson"},{"location":"stomp/conversions/jackson/#stomp-with-jackson","text":"The krossbow-stomp-jackson module is a JVM-only extension of krossbow-stomp-core that provides new APIs to send and receive properly typed classes, and automatically convert them to/from the JSON bodies of STOMP frames by leveraging Jackson and jackson-module-kotlin . The main addition is the extension function StompSession.withJacksonConversions() , which turns your StompSession into a StompSessionWithClassConversions . This new session type has additional methods that use reflection to convert your objects into JSON and back: StompClient (). connect ( url ). withJacksonConversions (). use { session -> session . convertAndSend ( \"/some/destination\" , Person ( \"Bob\" , 42 )) val messages : Flow < MyMessage > = session . subscribe < MyMessage > ( \"/some/topic/destination\" ) val firstMessage : MyMessage = messages . first () println ( \"Received: $ firstMessage \" ) }","title":"STOMP with Jackson"},{"location":"stomp/conversions/jackson/#using-a-custom-objectmapper","text":"Jackson is highly configurable, and it's often useful to configure the ObjectMapper manually. The withJacksonConversions() method takes an optional ObjectMapper parameter, so you can configure it as you please: val customObjectMapper : ObjectMapper = jacksonObjectMapper () . disable ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) . disable ( DeserializationFeature . FAIL_ON_IGNORED_PROPERTIES ) . enable ( SerializationFeature . ORDER_MAP_ENTRIES_BY_KEYS ) val client = StompClient (). connect ( url ) val session = client . withJacksonConversions ( customObjectMapper )","title":"Using a custom ObjectMapper"},{"location":"stomp/conversions/jackson/#dependency","text":"You will need to declare the following Gradle dependency to add these capabilities (you don't need the core module anymore as it is transitively brought by this one): implementation ( \"org.hildan.krossbow:krossbow-stomp-jackson:3.3.1\" ) This dependency transitively brings Jackson 2.13.2 with the Kotlin module .","title":"Dependency"},{"location":"stomp/conversions/kx-serialization/","text":"STOMP with Kotlinx Serialization \u00b6 Kotlinx Serialization is a multiplatform and multi-format serialization library provided by the Kotlin team. It is a popular choice for Kotlin multiplatform libraries especially because of its extensive support of Kotlin features. The krossbow-stomp-kxserialization module is an extension of krossbow-stomp-core that provides new APIs to send and receive properly typed classes, and automatically convert STOMP frame bodies by leveraging Kotlinx Serialization. Basic usage \u00b6 This module brings the following extension functions: StompSession.withBinaryConversions(format: BinaryFormat, mediaType: String) StompSession.withTextConversions(format: StringFormat, mediaType: String) StompSession.withJsonConversions() (requires a peer dependency on kotlinx-serialization-json , see below) which turn your StompSession into a StompSessionWithKxSerialization . This new session type has additional methods that use Kotlinx Serialization's serializers to serialize/deserialize your objects using the format of your choice (JSON, protobuf, etc.). You can for instance use convertAndSend and subscribe overloads with serializers like this: import org.hildan.krossbow.stomp.* import org.hildan.krossbow.stomp.conversions.kxserialization.* @Serializable data class Person ( val name : String , val age : Int ) @Serializable data class MyMessage ( val timestamp : Long , val author : String , val content : String ) val session = StompClient (). connect ( url ) val jsonStompSession = session . withJsonConversions () // adds convenience methods for kotlinx.serialization's conversions jsonStompSession . use { s -> s . convertAndSend ( \"/some/destination\" , Person ( \"Bob\" , 42 ), Person . serializer ()) // overloads without explicit serializers exist, but should be avoided if you also target JavaScript val messages : Flow < MyMessage > = s . subscribe ( \"/some/topic/destination\" , MyMessage . serializer ()) messages . collect { msg -> println ( \"Received message from ${ msg . author } : ${ msg . content } \" ) } } Custom Json instance \u00b6 The withJsonConversions() method takes an optional Json parameter, so you can configure it as you please: // custom Json configuration val json = Json { encodeDefaults = true ignoreUnknownKeys = true } val session = StompClient (). connect ( url ) val jsonStompSession = session . withJsonConversions ( json ) Dependency \u00b6 You will need to declare the following Gradle dependency to add these capabilities (you don't need the core module anymore as it is transitively brought by this one): implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:3.3.1\" ) Extra configuration \u00b6 Krossbow is format-agnostic, so you also need to add a Kotlinx Serialization dependency for the format you want to use. In the case of JSON, that would be kotlinx-serialization-json : implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:3.3.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.2\" ) Note that Kotlinx Serialization also requires a compiler plugin to generate serializers for your @Serializable classes. See the Kotlinx Serialization doc for more information about this.","title":"Kotlinx Serialization"},{"location":"stomp/conversions/kx-serialization/#stomp-with-kotlinx-serialization","text":"Kotlinx Serialization is a multiplatform and multi-format serialization library provided by the Kotlin team. It is a popular choice for Kotlin multiplatform libraries especially because of its extensive support of Kotlin features. The krossbow-stomp-kxserialization module is an extension of krossbow-stomp-core that provides new APIs to send and receive properly typed classes, and automatically convert STOMP frame bodies by leveraging Kotlinx Serialization.","title":"STOMP with Kotlinx Serialization"},{"location":"stomp/conversions/kx-serialization/#basic-usage","text":"This module brings the following extension functions: StompSession.withBinaryConversions(format: BinaryFormat, mediaType: String) StompSession.withTextConversions(format: StringFormat, mediaType: String) StompSession.withJsonConversions() (requires a peer dependency on kotlinx-serialization-json , see below) which turn your StompSession into a StompSessionWithKxSerialization . This new session type has additional methods that use Kotlinx Serialization's serializers to serialize/deserialize your objects using the format of your choice (JSON, protobuf, etc.). You can for instance use convertAndSend and subscribe overloads with serializers like this: import org.hildan.krossbow.stomp.* import org.hildan.krossbow.stomp.conversions.kxserialization.* @Serializable data class Person ( val name : String , val age : Int ) @Serializable data class MyMessage ( val timestamp : Long , val author : String , val content : String ) val session = StompClient (). connect ( url ) val jsonStompSession = session . withJsonConversions () // adds convenience methods for kotlinx.serialization's conversions jsonStompSession . use { s -> s . convertAndSend ( \"/some/destination\" , Person ( \"Bob\" , 42 ), Person . serializer ()) // overloads without explicit serializers exist, but should be avoided if you also target JavaScript val messages : Flow < MyMessage > = s . subscribe ( \"/some/topic/destination\" , MyMessage . serializer ()) messages . collect { msg -> println ( \"Received message from ${ msg . author } : ${ msg . content } \" ) } }","title":"Basic usage"},{"location":"stomp/conversions/kx-serialization/#custom-json-instance","text":"The withJsonConversions() method takes an optional Json parameter, so you can configure it as you please: // custom Json configuration val json = Json { encodeDefaults = true ignoreUnknownKeys = true } val session = StompClient (). connect ( url ) val jsonStompSession = session . withJsonConversions ( json )","title":"Custom Json instance"},{"location":"stomp/conversions/kx-serialization/#dependency","text":"You will need to declare the following Gradle dependency to add these capabilities (you don't need the core module anymore as it is transitively brought by this one): implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:3.3.1\" )","title":"Dependency"},{"location":"stomp/conversions/kx-serialization/#extra-configuration","text":"Krossbow is format-agnostic, so you also need to add a Kotlinx Serialization dependency for the format you want to use. In the case of JSON, that would be kotlinx-serialization-json : implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:3.3.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.2\" ) Note that Kotlinx Serialization also requires a compiler plugin to generate serializers for your @Serializable classes. See the Kotlinx Serialization doc for more information about this.","title":"Extra configuration"},{"location":"websocket/core/","text":"Krossbow Web Socket Core \u00b6 The krossbow-websocket-core module defines a standard web socket API abstraction. Different web socket implementations can be used in Krossbow as long as they match the interfaces defined here. Built-in implementations \u00b6 This core module already adapts some built-in implementations on each platform to this common interface: JS: the browser's native WebSocket API JVM: the built-in JDK11+ asynchronous java.net.http.WebSocket iOS, tvOS, watchOS: the native Foundation websocket using NSURLSessionWebSocketTask Note that these built-in implementations don't bring in any transitive dependencies. The ones that do need dependencies are part of different modules, so that they can be included separately only if needed. Creating your own implementation \u00b6 You can create your own implementation of Krossbow's web socket client by implementing the org.hildan.krossbow.websocket.WebSocketClient interface. This interface simply has a connect() method returning an instance of WebSocketConnection . The WebSocketConnection actually contains the bulk of the web socket interactions implementation. Please follow the KDoc of these interfaces to learn more about the contract that needs to be satisfied for each method. Dependency information \u00b6 You can add the following to your build.gradle : implementation ( \"org.hildan.krossbow:krossbow-websocket-core:3.3.1\" ) You probably don't need it The krossbow-websocket-core dependency is transitively brought by all STOMP modules, so you only need it if you're exclusively interested in the bare Web Socket features without STOMP protocol.","title":"Core (built-in)"},{"location":"websocket/core/#krossbow-web-socket-core","text":"The krossbow-websocket-core module defines a standard web socket API abstraction. Different web socket implementations can be used in Krossbow as long as they match the interfaces defined here.","title":"Krossbow Web Socket Core"},{"location":"websocket/core/#built-in-implementations","text":"This core module already adapts some built-in implementations on each platform to this common interface: JS: the browser's native WebSocket API JVM: the built-in JDK11+ asynchronous java.net.http.WebSocket iOS, tvOS, watchOS: the native Foundation websocket using NSURLSessionWebSocketTask Note that these built-in implementations don't bring in any transitive dependencies. The ones that do need dependencies are part of different modules, so that they can be included separately only if needed.","title":"Built-in implementations"},{"location":"websocket/core/#creating-your-own-implementation","text":"You can create your own implementation of Krossbow's web socket client by implementing the org.hildan.krossbow.websocket.WebSocketClient interface. This interface simply has a connect() method returning an instance of WebSocketConnection . The WebSocketConnection actually contains the bulk of the web socket interactions implementation. Please follow the KDoc of these interfaces to learn more about the contract that needs to be satisfied for each method.","title":"Creating your own implementation"},{"location":"websocket/core/#dependency-information","text":"You can add the following to your build.gradle : implementation ( \"org.hildan.krossbow:krossbow-websocket-core:3.3.1\" ) You probably don't need it The krossbow-websocket-core dependency is transitively brought by all STOMP modules, so you only need it if you're exclusively interested in the bare Web Socket features without STOMP protocol.","title":"Dependency information"},{"location":"websocket/ktor/","text":"Krossbow with Ktor \u00b6 Krossbow allows you to use Ktor's web socket as transport for STOMP. Ktor's implementation supports a variety of platforms and is very popular in the Kotlin world, especially in Kotlin multiplatform. The krossbow-websocket-ktor module provides the KtorWebSocketClient , which adapts Ktor's HttpClient to Krossbow's web socket interface. Usage with StompClient \u00b6 To use the KtorWebSocketClient instead of the platform default, you need to specify it when creating your StompClient : val client = StompClient ( KtorWebSocketClient ()) You can customize the actual Ktor HTTP client used behind the scenes by passing it to KtorWebSocketClient : // You may configure Ktor HTTP client as you please, // but make sure at least the websocket feature is installed val httpClient = HttpClient { install ( WebSockets ) } val wsClient = KtorWebSocketClient ( httpClient ) val stompClient = StompClient ( wsClient ) Dependency information \u00b6 You will need to declare the following Gradle dependency to use the KtorWebSocketClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:3.3.1\" ) Ktor uses pluggable engines to perform the platform-specific network operations (just like Krossbow uses different web socket implementations). You need to pick an engine that supports web sockets in order to use Ktor's HttpClient with web sockets. Follow Ktor's documentation to find out more about how to use engines. For instance, if you want to use Ktor's CIO engine with Krossbow, you need to declare the following: implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:3.3.1\" ) implementation ( \"io.ktor:ktor-client-cio:1.6.8\" )","title":"Ktor"},{"location":"websocket/ktor/#krossbow-with-ktor","text":"Krossbow allows you to use Ktor's web socket as transport for STOMP. Ktor's implementation supports a variety of platforms and is very popular in the Kotlin world, especially in Kotlin multiplatform. The krossbow-websocket-ktor module provides the KtorWebSocketClient , which adapts Ktor's HttpClient to Krossbow's web socket interface.","title":"Krossbow with Ktor"},{"location":"websocket/ktor/#usage-with-stompclient","text":"To use the KtorWebSocketClient instead of the platform default, you need to specify it when creating your StompClient : val client = StompClient ( KtorWebSocketClient ()) You can customize the actual Ktor HTTP client used behind the scenes by passing it to KtorWebSocketClient : // You may configure Ktor HTTP client as you please, // but make sure at least the websocket feature is installed val httpClient = HttpClient { install ( WebSockets ) } val wsClient = KtorWebSocketClient ( httpClient ) val stompClient = StompClient ( wsClient )","title":"Usage with StompClient"},{"location":"websocket/ktor/#dependency-information","text":"You will need to declare the following Gradle dependency to use the KtorWebSocketClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:3.3.1\" ) Ktor uses pluggable engines to perform the platform-specific network operations (just like Krossbow uses different web socket implementations). You need to pick an engine that supports web sockets in order to use Ktor's HttpClient with web sockets. Follow Ktor's documentation to find out more about how to use engines. For instance, if you want to use Ktor's CIO engine with Krossbow, you need to declare the following: implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:3.3.1\" ) implementation ( \"io.ktor:ktor-client-cio:1.6.8\" )","title":"Dependency information"},{"location":"websocket/okhttp/","text":"Krossbow with OkHttp \u00b6 Krossbow allows you to use OkHttp's WebSocket as transport for STOMP. OkHttp is very popular on Android, and is already part of many projects as HTTP client of choice. The krossbow-websocket-okhttp module provides the OkHttpWebSocketClient , which adapts OkHttp's WebSocket to Krossbow's web socket interface. Usage with StompClient \u00b6 To use the OkHttpWebSocketClient instead of the platform default, you need to specify it when creating your StompClient : val client = StompClient ( OkHttpWebSocketClient ()) You can customize the actual OkHttpClient used behind the scenes by passing it to OkHttpWebSocketClient : // This allows to configure the underlying OkHttpClient as you please // (or use an existing one from your project) val okHttpClient = OkHttpClient . Builder () . callTimeout ( Duration . ofMinutes ( 1 )) . pingInterval ( Duration . ofSeconds ( 10 )) . build () val wsClient = OkHttpWebSocketClient ( okHttpClient ) val stompClient = StompClient ( wsClient ) Dependency information \u00b6 You will need to declare the following Gradle dependency to use the OkHttpWebSocketClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-okhttp:3.3.1\" )","title":"OkHttp"},{"location":"websocket/okhttp/#krossbow-with-okhttp","text":"Krossbow allows you to use OkHttp's WebSocket as transport for STOMP. OkHttp is very popular on Android, and is already part of many projects as HTTP client of choice. The krossbow-websocket-okhttp module provides the OkHttpWebSocketClient , which adapts OkHttp's WebSocket to Krossbow's web socket interface.","title":"Krossbow with OkHttp"},{"location":"websocket/okhttp/#usage-with-stompclient","text":"To use the OkHttpWebSocketClient instead of the platform default, you need to specify it when creating your StompClient : val client = StompClient ( OkHttpWebSocketClient ()) You can customize the actual OkHttpClient used behind the scenes by passing it to OkHttpWebSocketClient : // This allows to configure the underlying OkHttpClient as you please // (or use an existing one from your project) val okHttpClient = OkHttpClient . Builder () . callTimeout ( Duration . ofMinutes ( 1 )) . pingInterval ( Duration . ofSeconds ( 10 )) . build () val wsClient = OkHttpWebSocketClient ( okHttpClient ) val stompClient = StompClient ( wsClient )","title":"Usage with StompClient"},{"location":"websocket/okhttp/#dependency-information","text":"You will need to declare the following Gradle dependency to use the OkHttpWebSocketClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-okhttp:3.3.1\" )","title":"Dependency information"},{"location":"websocket/sockjs/","text":"Krossbow with SockJS \u00b6 Krossbow allows you to use SockJS-compatible clients as transport for STOMP. The krossbow-websocket-sockjs is a multiplatform facade implementing Krossbow's web socket interface by relying on different SockJS implementations. Here are the backing implementations for the different platforms: JS (browser and NodeJS): the sockjs-client library (isomorphic) JVM: Spring's WebSocketClient (with SockJS enabled), through krossbow-websocket-spring Using a SockJS client requires a SockJS-enabled server. Usage with StompClient \u00b6 To use this client, just call SockJSClient() and the relevant platform-specific client will be instantiated for you: val client = StompClient ( SockJSClient ()) Dependency information \u00b6 You will need to declare the following Gradle dependency to use the SockJSClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-sockjs:3.3.1\" )","title":"SockJS"},{"location":"websocket/sockjs/#krossbow-with-sockjs","text":"Krossbow allows you to use SockJS-compatible clients as transport for STOMP. The krossbow-websocket-sockjs is a multiplatform facade implementing Krossbow's web socket interface by relying on different SockJS implementations. Here are the backing implementations for the different platforms: JS (browser and NodeJS): the sockjs-client library (isomorphic) JVM: Spring's WebSocketClient (with SockJS enabled), through krossbow-websocket-spring Using a SockJS client requires a SockJS-enabled server.","title":"Krossbow with SockJS"},{"location":"websocket/sockjs/#usage-with-stompclient","text":"To use this client, just call SockJSClient() and the relevant platform-specific client will be instantiated for you: val client = StompClient ( SockJSClient ())","title":"Usage with StompClient"},{"location":"websocket/sockjs/#dependency-information","text":"You will need to declare the following Gradle dependency to use the SockJSClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-sockjs:3.3.1\" )","title":"Dependency information"},{"location":"websocket/spring/","text":"Krossbow with Spring \u00b6 Krossbow allows you to use Spring's WebSocketClient as transport for STOMP. The krossbow-websocket-spring module provides the SpringWebSocketClientAdapter , which adapts any of Spring's WebSocketClient to Krossbow's web socket interface. On top of that, some pre-configured clients are provided: SpringDefaultWebSocketClient : based on the StandardWebSocketClient , which relies on the JSR-356 ( javax.websocket.* ) web socket standard. SpringSockJSWebSocketClient : an implementation using the SockJS protocol (requires a SockJS server), based on the standard web socket client, with the ability to fall back to other transports (like RestTemplateXhrTransport ). SpringJettyWebSocketClient : based on the JettyWebSocketClient (requires Jetty dependency, see below) Usage with StompClient \u00b6 Predefined clients \u00b6 To use one of the predefined Spring clients, you need to specify it when creating your StompClient : val stompClient = StompClient ( SpringDefaultWebSocketClient ) Or using the default SockJS client: val stompClient = StompClient ( SpringSockJSWebSocketClient ) Custom SpringWebSocketClient \u00b6 You can also use your own SpringWebSocketClient by wrapping it in a SpringWebSocketClientAdapter : // Pure Spring configuration val springWsClient = StandardWebSocketClient (). apply { taskExecutor = SimpleAsyncTaskExecutor ( \"my-websocket-threads\" ) userProperties = mapOf ( \"my-prop\" to \"someValue\" ) } // Krossbow adapter val stompClient = StompClient ( SpringWebSocketClientAdapter ( springWsClient )) Another example of custom client, using Spring's SockJS client: // Pure Spring configuration val transports = listOf ( WebSocketTransport ( StandardWebSocketClient ()), RestTemplateXhrTransport ( myCustomRestTemplate ), ) val sockJsClient = SockJsClient ( transports ) // Krossbow adapter val stompClient = StompClient ( SpringWebSocketClientAdapter ( sockJsClient )) Dependency information \u00b6 You will need to declare the following Gradle dependency to use the Spring adapters: implementation ( \"org.hildan.krossbow:krossbow-websocket-spring:3.3.1\" ) If you're using the SpringDefaultWebSocketClient (or SpringSockJSWebSocketClient with default settings), you'll need to add a dependency on a JSR-356 implementation, such as Tyrus: implementation ( \"org.glassfish.tyrus.bundles:tyrus-standalone-client-jdk:1.17\" ) If you're using the SpringJettyWebSocketClient , you'll need to add a dependency on Jetty's web socket client: implementation ( \"org.eclipse.jetty.websocket:websocket-client:9.4.45.v20220203\" )","title":"Spring"},{"location":"websocket/spring/#krossbow-with-spring","text":"Krossbow allows you to use Spring's WebSocketClient as transport for STOMP. The krossbow-websocket-spring module provides the SpringWebSocketClientAdapter , which adapts any of Spring's WebSocketClient to Krossbow's web socket interface. On top of that, some pre-configured clients are provided: SpringDefaultWebSocketClient : based on the StandardWebSocketClient , which relies on the JSR-356 ( javax.websocket.* ) web socket standard. SpringSockJSWebSocketClient : an implementation using the SockJS protocol (requires a SockJS server), based on the standard web socket client, with the ability to fall back to other transports (like RestTemplateXhrTransport ). SpringJettyWebSocketClient : based on the JettyWebSocketClient (requires Jetty dependency, see below)","title":"Krossbow with Spring"},{"location":"websocket/spring/#usage-with-stompclient","text":"","title":"Usage with StompClient"},{"location":"websocket/spring/#predefined-clients","text":"To use one of the predefined Spring clients, you need to specify it when creating your StompClient : val stompClient = StompClient ( SpringDefaultWebSocketClient ) Or using the default SockJS client: val stompClient = StompClient ( SpringSockJSWebSocketClient )","title":"Predefined clients"},{"location":"websocket/spring/#custom-springwebsocketclient","text":"You can also use your own SpringWebSocketClient by wrapping it in a SpringWebSocketClientAdapter : // Pure Spring configuration val springWsClient = StandardWebSocketClient (). apply { taskExecutor = SimpleAsyncTaskExecutor ( \"my-websocket-threads\" ) userProperties = mapOf ( \"my-prop\" to \"someValue\" ) } // Krossbow adapter val stompClient = StompClient ( SpringWebSocketClientAdapter ( springWsClient )) Another example of custom client, using Spring's SockJS client: // Pure Spring configuration val transports = listOf ( WebSocketTransport ( StandardWebSocketClient ()), RestTemplateXhrTransport ( myCustomRestTemplate ), ) val sockJsClient = SockJsClient ( transports ) // Krossbow adapter val stompClient = StompClient ( SpringWebSocketClientAdapter ( sockJsClient ))","title":"Custom SpringWebSocketClient"},{"location":"websocket/spring/#dependency-information","text":"You will need to declare the following Gradle dependency to use the Spring adapters: implementation ( \"org.hildan.krossbow:krossbow-websocket-spring:3.3.1\" ) If you're using the SpringDefaultWebSocketClient (or SpringSockJSWebSocketClient with default settings), you'll need to add a dependency on a JSR-356 implementation, such as Tyrus: implementation ( \"org.glassfish.tyrus.bundles:tyrus-standalone-client-jdk:1.17\" ) If you're using the SpringJettyWebSocketClient , you'll need to add a dependency on Jetty's web socket client: implementation ( \"org.eclipse.jetty.websocket:websocket-client:9.4.45.v20220203\" )","title":"Dependency information"}]}