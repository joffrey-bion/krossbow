{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Krossbow is a Kotlin multiplatform STOMP 1.2 client with a coroutine-based API.</p> <p>It is built on a web socket client abstraction, and provides a bunch of adapters for popular web socket clients (OkHttp, Ktor, Spring, SockJS...). It also provides out-of-the-box a built-in web socket implementation (without third-party dependencies) for most platforms (see below).</p> <p>Krossbow can also be used as a multiplatform web socket client without STOMP protocol.</p>"},{"location":"#features","title":"Features","text":"<p>All the STOMP 1.2 specification is implemented:</p> <ul> <li>All STOMP frames, including <code>ACK</code>/<code>NACK</code> and transactions</li> <li>Text and binary bodies</li> <li>Receipts (waiting for <code>RECEIPT</code> frame based on receipt header)</li> <li>Heart beats (keep alive)</li> <li>Custom headers where the protocol allows them</li> </ul> <p>Additional features:</p> <ul> <li>Auto-receipts (automatically adds <code>receipt</code> headers to ensure no frame is lost)</li> <li>Built-in body conversions (Kotlinx Serialization or Jackson)</li> <li>Possibility to hook custom body converters (for textual or binary bodies)</li> <li>Automatic content length header for sent frames</li> </ul> <p>If you find a bug or a feature that's missing compared to the specification, please open an issue.</p>"},{"location":"#supported-targets","title":"Supported targets","text":"<p>Krossbow supports most Kotlin targets in its STOMP and web socket API modules: JVM, JS (browser and nodeJS), iOS, watchOS, tvOS, macOSX64, linuxX64, mingwX64. </p> <p>However, each web socket client implementation has its own subset of supported targets (see below).</p> <p>Android not tested on CI</p> <p>Android 5.0+ (API level 21+) is supported by using JVM artifacts (e.g. OkHttp). However, the Android tooling's desugaring is currently not tested as part of the build, so any feedback on this use case is more than welcome. Please upvote the corresponding issue if you'd like to see proper CI or special packaging for the Android target.</p>"},{"location":"#web-socket-clients-target-support","title":"Web socket clients target support","text":"<p>Krossbow can use built-in web socket implementations without third-party dependencies on some platforms. It also provides adapters for third-party implementations which have different platform support. Here is a summary of the supported platforms by module:</p> Module Browser NodeJS JVM iOS / tvOS / watchOS macOS / Linux / Windows Transitive dependencies Built-in  (JDK\u00a011+) None Ktor Ktor, and the relevant Ktor engine(s) OkHttp OkHttp SockJS sockjs-client (on JS), Spring websocket (on JVM) Spring Spring websocket <p> supported with actual web socket transport (RFC6455)</p> <p> supported using SockJS protocol (requires a SockJS server)</p>"},{"location":"#contribute","title":"Contribute","text":"<p>Don't hesitate to open GitHub issues, even to ask questions or discuss a new feature. Pull-requests are welcome, but please open an issue first so that we can discuss the initial design or fix, which may avoid unnecessary work.</p>"},{"location":"artifacts/","title":"Artifacts summary","text":"<p>Krossbow offers a lot of possibilities so here is a summary of all available artifacts.</p> <p>All these artifacts are published to Maven Central under the group ID <code>org.hildan.krossbow</code> and a common version.</p>"},{"location":"artifacts/#stomp-artifacts","title":"STOMP artifacts","text":"<p>You should pick only one of the <code>krossbow-stomp-*</code> artifacts, depending on whether you need automatic serialization of frame bodies:</p> Artifact Description <pre>krossbow-stomp-core</pre> The basic multiplatform STOMP client. It implements the STOMP 1.2 protocol on top of the web socket abstraction defined by the <code>krossbow-websocket-core</code> module. <pre>krossbow-stomp-jackson</pre> A superset of <code>krossbow-stomp-core</code> adding JSON conversion features using Jackson (JVM only) <pre>krossbow-stomp-moshi</pre> A superset of <code>krossbow-stomp-core</code> adding JSON conversion features using Moshi (JVM only) <pre>krossbow-stomp-kxserialization</pre> A superset of <code>krossbow-stomp-core</code> adding conversion features using Kotlinx Serialization library (multiplatform). You can leverage the multi-format capabilities of Kotlinx Serialization (JSON, protobuf, CBOR, ...). <pre>krossbow-stomp-kxserialization-json</pre> A superset of <code>krossbow-stomp-kxserialization</code> adding JSON helpers and the JSON format dependency. <p>Then add the dependency of your choice to your Gradle build. For instance, if you intend to use Krossbow with Kotlinx Serialization:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-stomp-kxserialization:5.7.0\")\n</code></pre> <p>Don't need STOMP?</p> <p>If you're just interested in the web socket client without STOMP protocol, don't declare a STOMP artifact, but  instead choose one of the web socket artifacts below.</p>"},{"location":"artifacts/#web-socket-artifacts","title":"Web Socket artifacts","text":"<p>The STOMP artifacts depend on a web socket API that needs an implementation. Krossbow provides implementations for the built-in web socket API of most platforms, and also adapters for 3rd-party web socket implementations:</p> Artifact Description <pre>krossbow-websocket-builtin</pre> A multiplatform <code>WebSocketClient</code> implementation that adapts the built-in client for each supported platform without transitive dependency. <pre>krossbow-websocket-ktor</pre> A multiplatform <code>WebSocketClient</code> implementation based on Ktor 2.3.4's <code>HttpClient</code>. <pre>krossbow-websocket-okhttp</pre> A JVM implementation of the web socket API using OkHttp's client. <pre>krossbow-websocket-sockjs</pre> A multiplatform <code>WebSocketClient</code> implementation for use with SockJS servers. It uses Spring's SockJSClient on JVM, and npm <code>sockjs-client</code> for JavaScript (NodeJS and browser). <pre>krossbow-websocket-spring</pre> A JVM 8+ implementation of the web socket API using Spring's WebSocketClient. Provides both a normal WebSocket client and a SockJS one. <p>Peer dependencies</p> <p>Some Krossbow modules are not opinionated and require some extra third-party peer dependencies. Make sure to read the usage section corresponding to the module of your choice for more details.  </p>"},{"location":"license/","title":"MIT License","text":"<p>Copyright (c) 2019-2023 Joffrey Bion</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"migration-guides/","title":"Migration guides","text":"<p>Here are some details about how to migrate from one major version to another.</p>"},{"location":"migration-guides/#from-4x-to-5x","title":"From 4.x to 5.x","text":""},{"location":"migration-guides/#end-of-ktor-1x-support","title":"End of Ktor 1.x support","text":"<p><code>krossbow-websocket-ktor-legacy</code> artifact was removed. This means Krossbow no longer works with Ktor 1.x. If you were using this module, please migrate to Ktor 2, and use the  non-legacy krossbow-websocket-ktor module.</p>"},{"location":"migration-guides/#kotlin-18","title":"Kotlin 1.8","text":"<p>This update of Krossbow brings Kotlin 1.8, which might bring some incompatible changes to the Kotlin stdlib. Please check the compatibility guide if you were using an  older version of Kotlin.</p>"},{"location":"migration-guides/#from-3x-to-4x","title":"From 3.x to 4.x","text":""},{"location":"migration-guides/#withjsonconversions-moved-to-its-own-module","title":"withJsonConversions moved to its own module","text":"<p>If you were using Krossbow with <code>krossbow-stomp-kxserialization</code>, the <code>withJsonConversions</code> helper has moved to a new module called <code>krossbow-stomp-kxserialization-json</code>. This new module now transitively brings <code>kotlinx-serialization-json</code> so you don't need to depend on that one explicitly.</p>"},{"location":"migration-guides/#built-in-web-socket-clients-moved-to-their-own-module-and-default-stompclient-constructor-removed","title":"Built-in web socket clients moved to their own module and default <code>StompClient</code> constructor removed","text":"<p>Up to (and including) version 3.x of Krossbow, the built-in web socket clients for the supported platforms were part of the <code>krossbow-websocket-core</code> module. This module provided a <code>WebSocketClient.Companion.default()</code> factory function to provide the built-in web socket implementation of the current platform. Likewise, the <code>krossbow-stomp-core</code> module provided a <code>StompClient</code> constructor that used the \"default\"  built-in web socket implementation for the current platform.</p> <p>This approach limited the targets supported by those 2 core modules, even though all of their functionality was  target-agnostic. In order to support all Kotlin platforms in pure Kotlin modules, the built-in websocket implementations had to be moved  to a separate module, and the constructor without web socket client was moved to a separate module (and later removed completely for simplicity).</p> <p>Breaking dependency changes, in short:</p> <ul> <li>if you used <code>WebSocketClient.default()</code> from <code>krossbow-websocket-core</code>, or any of the built-in clients directly,   simply change your dependency to <code>krossbow-websocket-builtin</code> instead.</li> <li>if you used the <code>StompClient()</code> constructor without WS client argument (using the default value), add an explicit    dependency on <code>krossbow-websocket-builtin</code> and pass the built-in client explicitly to the constructor:   <code>StompClient(WebSocketClient.default())</code>.</li> </ul> <p>Note: the <code>WebSocketClient.default()</code> function was since renamed <code>WebSocketClient.builtIn()</code> in newer versions.</p> <p>If you used other web socket implementations than the built-in ones, you don't have to change anything to your  dependencies.</p>"},{"location":"migration-guides/#from-2x-to-3x","title":"From 2.x to 3.x","text":""},{"location":"migration-guides/#use-durations-instead-of-millis","title":"Use Durations instead of millis","text":"<p><code>StompConfiguration</code> no longer uses amounts of milliseconds, but uses the <code>kotlin.time.Duration</code> API. The <code>-Millis</code> suffixes for the relevant properties were therefore dropped and the types changed.</p> <p>Before:</p> <pre><code>val stomp = StompClient {\nconnectionTimeoutMillis = 2000\nreceiptTimeoutMillis = 5000\ndisconnectTimeoutMillis = 300\n}\n</code></pre> <p>After: <pre><code>import kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.seconds\n\nval stomp = StompClient {\nconnectionTimeout = 2.seconds\nreceiptTimeout = 5.seconds\ndisconnectTimeout = 300.milliseconds\n}\n</code></pre></p>"},{"location":"migration-guides/#flow-instead-of-channel-in-websocketconnection","title":"Flow instead of Channel in WebSocketConnection","text":"<p>If you used the websocket API directly, the <code>incomingFrames</code> channel is now a <code>Flow</code>.</p> <p>Before:</p> <pre><code>val conn = wsClient.connect(url)\nfor (frame in conn.incomingFrames) {\n// do stuff\n}\n</code></pre> <p>After:</p> <pre><code>val conn = wsClient.connect(url)\nconn.incomingFrames.collect {\n// do stuff\n}\n</code></pre>"},{"location":"migration-guides/#tyrus-no-longer-embedded-in-krossbow-websocket-spring","title":"Tyrus no longer embedded in <code>krossbow-websocket-spring</code>","text":"<p><code>krossbow-websocket-spring</code> no longer transitively brings a dependency on Tyrus.</p> <p>If you didn't add any JSR-356 implementation manually, you now have to explicitly depend on one. If you want the same behaviour as before, add the Tyrus dependency to your <code>build.gradle.kts</code> as follows:</p> <pre><code>dependencies {\n    implementation(\"org.glassfish.tyrus.bundles:tyrus-standalone-client-jdk:2.1.3\")\n}\n</code></pre>"},{"location":"migration-guides/#from-1x-to-2x","title":"From 1.x to 2.x","text":""},{"location":"migration-guides/#stompsessionuse-now-passes-the-session-as-it-not-this","title":"<code>StompSession.use</code> now passes the session as <code>it</code>, not <code>this</code>","text":"<p>In order to align with Closeable.use, the lambda for <code>StompSession.use</code> now receives the session as an argument (<code>it</code>) and not receiver (<code>this</code>).</p> <p>Before:</p> <pre><code>StompClient().connect(url).use {\nsendText(\"/dest\", \"message\")\n}\n</code></pre> <p>After:</p> <pre><code>StompClient().connect(url).use {\nit.sendText(\"/dest\", \"message\")\n}\n// or\nStompClient().connect(url).use { session -&gt;\nsession.sendText(\"/dest\", \"message\")\n}\n</code></pre>"},{"location":"stomp/advanced-features/","title":"Advanced features","text":""},{"location":"stomp/advanced-features/#receipts-suspension","title":"Receipts &amp; Suspension","text":"<p>The STOMP protocol supports RECEIPT frames, allowing the client to know when the server has received a frame. This only happens if a receipt header is set on the client frame.</p> <p>If auto-receipt is enabled, a <code>receipt</code> header is automatically generated and added to all client frames supporting the mechanism, and for which a <code>receipt</code> header is not already present. If auto-receipt is not enabled, a <code>receipt</code> header may still be provided manually in the parameters of some overloads.</p> <p>When a <code>receipt</code> header is present (automatically added or manually provided), the method that is used to send the frame suspends until the corresponding RECEIPT frame is received from the server. If no RECEIPT frame is received from the server in the configured time limit, a <code>LostReceiptException</code> is thrown.</p> <p>If no receipt is provided and auto-receipt is disabled, the method used to send the frame doesn't wait for a RECEIPT frame and never throws <code>LostReceiptException</code>. Instead, it returns immediately after the underlying web socket implementation is done sending the frame.</p>"},{"location":"stomp/advanced-features/#heart-beats","title":"Heart beats","text":"<p>When configured, heart beats can be used as a keep-alive to detect if the connection is lost. The heartBeat property should be used to configure heart beats in the <code>StompClient</code>.</p> <p>Note that the heart beats for the STOMP session are negotiated with the server. The actual heart beats are defined by the CONNECTED frame received from the server as a result of the negotiation, and may differ from the <code>StompClient</code> configuration. The negotiation behaviour is defined by the specification.</p> <p>Sending and checking heart beats is automatically handled by <code>StompSession</code> implementations, depending on the result of  the negotiation with the server. If expected heart beats are not received in time, a <code>MissingHeartBeatException</code> is thrown and fails active subscriptions.</p>"},{"location":"stomp/advanced-features/#graceful-disconnect","title":"Graceful disconnect","text":"<p>The graceful disconnect (or graceful shutdown) is a disconnection procedure defined by the STOMP specification to make sure the  server gets all the frames before dropping the connection.</p> <p>If enabled in the config, when disconnecting from the server, the client first sends a  DISCONNECT frame with a <code>receipt</code> header, and then waits for a RECEIPT frame before closing the connection.</p> <p>If this graceful disconnect is disabled, then calling <code>StompSession.disconnect()</code> immediately closes the web socket connection. In this case, there is no guarantee that the server received all previous messages.</p>"},{"location":"stomp/advanced-features/#using-custom-headers-in-the-web-socket-handshake","title":"Using custom headers in the web socket handshake","text":"<p>Not supported in browsers</p> <p>The browser's <code>WebSocket</code> API does not support custom headers in the handshake (see this open issue in the web socket standard repo). Because of this, Krossbow cannot support this feature for the JS browser platform. However, the JS web socket client adapter is designed in a way that allows other implementations to support it, such as a Node.js implementation.</p> <p>Some servers or connection flows may require extra HTTP headers in the web socket handshake. The <code>StompClient.connect()</code> function doesn't support such headers out of the box, but this function is essentially just a shorthand for connecting at the web socket level, and then connecting at the STOMP level.</p> <p>In fact, we technically don't need to create and use a <code>StompClient</code> at all in order to use STOMP with Krossbow. Krossbow provides a WebSocketConnection.stomp() extension function that establishes a STOMP connection from an existing web socket connection.</p> <p>We can leverage this to customize the web socket connection at will before connecting at STOMP level. For example:</p> <pre><code>val webSocketClient = WebSocketClient.builtIn() // or another web socket client\n\n// connect at web socket level with custom headers\nval wsSession = webSocketClient.connect(url, headers = mapOf(\"Custom-Header\" to \"custom-value\"))\n\nval config = StompConfig().apply {\n// here you can set up whatever config you would have done in the StompClient { ... } block\n}\n// connect at STOMP level on this open web socket, using the above config\nval stompSession = wsSession.stomp(config)\n</code></pre>"},{"location":"stomp/config/","title":"Configuration","text":""},{"location":"stomp/config/#configuring-the-stompclient","title":"Configuring the StompClient","text":"<p>The <code>StompClient</code> can be configured at construction time using a convenient lambda block:</p> <pre><code>val stompClient = StompClient(WebSocketClient.builtIn()) {\nconnectionTimeout = 3.seconds\ngracefulDisconnect = false\n}\n</code></pre> <p>You can also create the configuration separately and then pass it when constructing the client:</p> <pre><code>val stompConfig = StompConfig().apply {\nconnectionTimeout = 3.seconds\ngracefulDisconnect = false\n}\n\nval stompClient = StompClient(WebSocketClient.builtIn(), stompConfig)\n</code></pre>"},{"location":"stomp/config/#configuration-options","title":"Configuration options","text":"<p>You can find out about all configuration properties in the StompConfig KDoc.</p> <code>autoReceipt</code> (default: false) Whether to automatically attach a <code>receipt</code> header to the sent frames in order to track receipts. <code>autoContentLength</code> (default: true) Whether to automatically compute and add the <code>content-length</code> header in sent frames. <code>connectWithStompCommand</code> (default: false) <p>Whether to use the <code>STOMP</code> command instead of <code>CONNECT</code> to establish the connection.</p> <p>Clients that use the <code>STOMP</code> frame instead of the <code>CONNECT</code> frame will only be able to connect to STOMP 1.2 servers (as well as some STOMP 1.1 servers) but the advantage is that a protocol sniffer/discriminator will be able to differentiate the STOMP connection from an HTTP connection.</p> <code>heartBeat</code> (default: none) <p>The heart beats to request for the STOMP sessions.</p> <p>This is part of a negotiation and does not imply that this exact heart beat configuration will be used. The actual heart beats are defined by the CONNECTED frame received from the server as a result of the negotiation. This behaviour is defined by the specification.</p> <code>heartBeatTolerance</code> (default: none) <p>Defines tolerance for heart beats.</p> <p>If both the client and server really stick to the heart beats periods negotiated and given by the CONNECTED frame, network latencies will make them miss their marks. That's why we need some sort of tolerance.</p> <p>In case the server is too strict about its expectations, we can send heart beats a little bit earlier than we're supposed to (see <code>HeartBeatTolerance.outgoingMargin</code>).</p> <p>In case the server really sticks to its own period without such margin, we need to allow a little bit of delay to make up for network latencies before we fail and close the connection (see <code>HeartBeatTolerance.incomingMargin</code>).</p> <code>connectionTimeout</code> (default: 15s) Defines how long to wait for the websocket+STOMP connection to be established before throwing an exception. <code>receiptTimeout</code> (default: 1s) <p>Defines how long to wait for a RECEIPT frame from the server before throwing a <code>LostReceiptException</code>. Only crashes when a <code>receipt</code> header was actually present in the sent frame (and thus a RECEIPT was expected). Such header is always present if <code>autoReceipt</code> is enabled.</p> <p>Note that this doesn't apply to the DISCONNECT frames, use <code>disconnectTimeout</code> instead for that.</p> <code>disconnectTimeout</code> (default: 200ms) <p>Like <code>receiptTimeout</code> but only for the receipt of the DISCONNECT frame. This is ignored if <code>gracefulDisconnect</code> is disabled.</p> <p>Note that if this timeout expires, the [StompSession.disconnect] call doesn't throw an exception. This is to allow servers to close the connection quickly (sometimes too quick for sending a RECEIPT/ERROR) as mentioned in the specification.</p> <code>gracefulDisconnect</code> (default: true) <p>Enables graceful disconnect.</p> <p>If enabled, when disconnecting from the server, the client first sends a DISCONNECT frame with a <code>receipt</code> header, and then waits for a RECEIPT frame before closing the connection.</p> <p>If this graceful disconnect is disabled, then calling [StompSession.disconnect] immediately closes the web socket connection. In this case, there is no guarantee that the server received all previous messages.</p> <code>instrumentation</code> A set of hooks that are called in different places of the internal execution of Krossbow. The instrumentation can be used for monitoring, logging or debugging purposes."},{"location":"stomp/getting-started/","title":"Getting started","text":""},{"location":"stomp/getting-started/#gradle-setup","title":"Gradle setup","text":"<p>For the basic usage of STOMP without serialization, add the <code>krossbow-stomp-core</code> dependency as well as the web socket module of your choice.</p> <p>For example to use STOMP with Ktor's web socket client:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-stomp-core:5.7.0\")\nimplementation(\"org.hildan.krossbow:krossbow-websocket-ktor:5.7.0\")\n</code></pre> <p>Check out the web socket client table to help you choose. We recommend the built-in client adapters if they cover the Kotlin targets you need to support, in order to limit 3rd party dependencies. Otherwise, Ktor is a good choice if you don't have special needs like SockJS.</p>"},{"location":"stomp/getting-started/#basic-usage-without-body-conversions","title":"Basic usage (without body conversions)","text":"<p>This is how to create a STOMP client and interact with it:</p> <pre><code>import kotlinx.coroutines.flow.*\nimport org.hildan.krossbow.stomp.*\nimport org.hildan.krossbow.websocket.*\nimport org.hildan.krossbow.websocket.builtin.*\n\nval client = StompClient(WebSocketClient.builtIn()) // other config can be passed in here\nval session: StompSession = client.connect(url) // optional login/passcode can be provided here\n\nsession.sendText(\"/some/destination\", \"Basic text message\") // this triggers a SUBSCRIBE frame and returns the flow of messages for the subscription\nval subscription: Flow&lt;String&gt; = session.subscribeText(\"/some/topic/destination\")\n\nval collectorJob = launch {\nsubscription.collect { msg -&gt;\nprintln(\"Received: $msg\")\n}\n}\ndelay(3000)\n// cancelling the flow collector triggers an UNSUBSCRIBE frame\ncollectorJob.cancel()\n\nsession.disconnect()\n</code></pre> <p>If you want to disconnect automatically in case of exception or normal termination, you can use a <code>try</code>/<code>finally</code> block, or use <code>StompSession.use()</code>, which is similar to <code>Closeable.use()</code>:</p> <pre><code>import kotlinx.coroutines.flow.*\nimport org.hildan.krossbow.stomp.*\nimport org.hildan.krossbow.websocket.*\nimport org.hildan.krossbow.websocket.builtin.*\n\nval client = StompClient(WebSocketClient.builtIn()) // other config can be passed in here\nval session: StompSession = client.connect(url) // optional login/passcode can be provided here\n\nsession.use { s -&gt;\ns.sendText(\"/some/destination\", \"Basic text message\") val subscription: Flow&lt;String&gt; = s.subscribeText(\"/some/topic/destination\")\n\n// terminal operators that finish early (like first) also trigger UNSUBSCRIBE automatically\nval firstMessage: String = subscription.first()\nprintln(\"Received: $firstMessage\")\n}\n// DISCONNECT frame was automatically sent at the end of the use{...} block\n</code></pre>"},{"location":"stomp/getting-started/#using-body-conversions","title":"Using body conversions","text":"<p>You can use STOMP with basic text as frame bodies, but it really becomes interesting when you can convert the frame bodies back and forth into Kotlin objects.</p> <p>Check out the following sections to see how to automatically convert your objects into STOMP frame bodies:</p> <ul> <li>using Kotlinx Serialization (multiplatform)</li> <li>using Jackson (JVM-only)</li> <li>using Moshi (JVM-only)</li> <li>using custom conversions</li> </ul>"},{"location":"stomp/conversions/custom/","title":"Custom conversions","text":"<p>If you want to use your own text conversion, you can implement <code>TextMessageConverter</code> without any additional module, and use <code>withTextConversions</code> to wrap your <code>StompSession</code> into a <code>TypedStompSession</code>.</p> <p>Limited JS support</p> <p>Reflection-based conversions may behave poorly on the JS platform. It is usually safer to rely on Kotlinx Serialization for multiplatform conversions.</p> <pre><code>val myConverter = object : TextMessageConverter {\noverride val mimeType: String = \"application/json;charset=utf-8\"\n\noverride fun &lt;T&gt; convertToString(value: T, type: KTypeRef&lt;T&gt;): String {\nTODO(\"your own object -&gt; text conversion\")\n}\n\noverride fun &lt;T&gt; convertFromString(text: String, type: KTypeRef&lt;T&gt;): T {\nTODO(\"your own text -&gt; object conversion\")\n}\n}\n\nStompClient(WebSocketClient.builtIn()).connect(url).withTextConversions(myConverter).use { session -&gt;\nsession.convertAndSend(\"/some/destination\", MyPojo(\"Custom\", 42)) val messages = session.subscribe&lt;MyMessage&gt;(\"/some/topic/destination\")\nval firstMessage: MyMessage = messages.first()\n\nprintln(\"Received: $firstMessage\")\n}\n</code></pre>"},{"location":"stomp/conversions/jackson/","title":"STOMP with Jackson","text":"<p>The <code>krossbow-stomp-jackson</code> module is a JVM-only extension of <code>krossbow-stomp-core</code> that provides new APIs to send and receive properly typed classes, and automatically convert them to/from the JSON bodies of STOMP frames by leveraging Jackson and  jackson-module-kotlin.</p> <p>The main addition is the extension function <code>StompSession.withJackson()</code>, which turns your <code>StompSession</code> into a <code>TypedStompSession</code>. This new session type has additional methods that use Jackson to convert your objects into JSON and back:</p> <pre><code>StompClient(WebSocketClient.builtIn()).connect(url).withJackson().use { session -&gt;\nsession.convertAndSend(\"/some/destination\", Person(\"Bob\", 42)) val messages: Flow&lt;MyMessage&gt; = session.subscribe&lt;MyMessage&gt;(\"/some/topic/destination\")\nval firstMessage: MyMessage = messages.first()\n\nprintln(\"Received: $firstMessage\")\n}\n</code></pre>"},{"location":"stomp/conversions/jackson/#using-a-custom-objectmapper","title":"Using a custom <code>ObjectMapper</code>","text":"<p>Jackson is highly configurable, and it's often useful to configure the <code>ObjectMapper</code> manually.</p> <p>The <code>withJackson()</code> method takes an optional <code>ObjectMapper</code> parameter, so you can configure it as you please:</p> <pre><code>val customObjectMapper: ObjectMapper = jacksonObjectMapper()\n.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n.disable(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES)\n.enable(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)\n\nval client = StompClient(WebSocketClient.builtIn()).connect(url)\nval session = client.withJackson(customObjectMapper)\n</code></pre>"},{"location":"stomp/conversions/jackson/#dependency","title":"Dependency","text":"<p>To use Jackson conversions, add <code>krossbow-stomp-jackson</code> to your Gradle dependencies (<code>krossbow-stomp-core</code> is unnecessary because it's transitively brought by this one):</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-stomp-jackson:5.7.0\")\n</code></pre> <p>This dependency transitively brings Jackson 2.15.2 with the Kotlin module.</p>"},{"location":"stomp/conversions/kx-serialization/","title":"STOMP with Kotlinx Serialization","text":"<p>Kotlinx Serialization is a multiplatform and multi-format serialization library provided by the Kotlin team. It is a popular choice for Kotlin multiplatform libraries especially because of its extensive support of Kotlin features.</p> <p>The <code>krossbow-stomp-kxserialization</code> module is an extension of <code>krossbow-stomp-core</code> that provides new APIs to  send and receive properly typed classes, and automatically convert STOMP frame bodies by leveraging Kotlinx Serialization.</p>"},{"location":"stomp/conversions/kx-serialization/#usage-with-the-json-format","title":"Usage with the JSON format","text":"<p>Since Kotlinx Serialization supports multiple formats with different dependencies, you normally have to add your own dependency to bring the format of your choice.</p> <p>However, since JSON is so popular, Krossbow comes with the <code>krossbow-stomp-kxserialization-json</code> module, which adds  dedicated helpers for JSON and the necessary transitive dependency on the JSON format (see dependencies section below).</p> <p>This module brings the withJsonConversions helper to convert your <code>StompSession</code> into a <code>StompSessionWithKxSerialization</code>:</p> <pre><code>val session = StompClient(WebSocketClient.builtIn()).connect(url)\nval jsonStompSession = session.withJsonConversions()\n</code></pre> <p>This new session type has the additional <code>convertAndSend</code> method and <code>subscribe</code> overloads that use Kotlinx Serialization's serializers to convert your payloads using the format of your choice (in this case, JSON):</p> <pre><code>@Serializable\ndata class Person(val name: String, val age: Int)\n@Serializable\ndata class MyMessage(val timestamp: Long, val author: String, val content: String)\n\njsonStompSession.use { s -&gt;\ns.convertAndSend(\"/some/destination\", Person(\"Bob\", 42), Person.serializer()) // overloads without explicit serializers exist, but should be avoided if you also target JavaScript\nval messages: Flow&lt;MyMessage&gt; = s.subscribe(\"/some/topic/destination\", MyMessage.serializer())\n\nmessages.collect { msg -&gt;\nprintln(\"Received message from ${msg.author}: ${msg.content}\")\n}\n}\n</code></pre>"},{"location":"stomp/conversions/kx-serialization/#custom-json-instance","title":"Custom <code>Json</code> instance","text":"<p>The <code>withJsonConversions()</code> method takes an optional <code>Json</code> parameter, so you can configure it as you please:</p> <pre><code>// custom Json configuration\nval json = Json {\nencodeDefaults = true\nignoreUnknownKeys = true\n}\n\nval session = StompClient(WebSocketClient.builtIn()).connect(url)\nval jsonStompSession = session.withJsonConversions(json)\n</code></pre>"},{"location":"stomp/conversions/kx-serialization/#usage-with-other-formats","title":"Usage with other formats","text":"<p>For other formats than JSON, use the more general <code>krossbow-stomp-kxserialization</code> module, and add a dependency on the Kotlinx Serialization format of your choice (see dependencies section below).</p> <p>This module brings the following extension functions on <code>StompSession</code>:</p> <ul> <li><code>withBinaryConversions(format: BinaryFormat, mediaType: String)</code></li> <li><code>withTextConversions(format: StringFormat, mediaType: String)</code></li> </ul> <p>These helpers are equivalent to <code>withJsonConversions</code>, but more general, and also turn your <code>StompSession</code> into a <code>StompSessionWithKxSerialization</code>. You should provide the media type that you want to set as <code>content-type</code> header in the messages you send:</p> <pre><code>val session = StompClient(WebSocketClient.builtIn()).connect(url)\nval jsonStompSession = session.withBinaryConversions(Protobuf.Default, \"application/x-protobuf\")\n</code></pre> <p>You can then use <code>convertAndSend</code> and <code>subscribe</code> the same way as in the JSON section above.</p>"},{"location":"stomp/conversions/kx-serialization/#dependency","title":"Dependency","text":""},{"location":"stomp/conversions/kx-serialization/#general-case","title":"General case","text":"<p>Krossbow's base Kotlinx Serialization module is format-agnostic, so you need to add both the <code>krossbow-stomp-kxserialization</code> dependency and the Kotlinx Serialization dependency for the format you want to use. For instance in the case of protobuf, that would be <code>kotlinx-serialization-protobuf</code>:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-stomp-kxserialization:5.7.0\")\nimplementation(\"org.jetbrains.kotlinx:kotlinx-serialization-protobuf:1.6.0\")\n</code></pre>"},{"location":"stomp/conversions/kx-serialization/#json-format","title":"JSON format","text":"<p>Since JSON is so common, Krossbow provides an all-in-one module with additional helpers for JSON:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-stomp-kxserialization-json:5.7.0\")\n</code></pre> <p>This module brings <code>kotlinx-serialization-json</code> transitively, so you don't have to add it yourself.</p>"},{"location":"stomp/conversions/kx-serialization/#additional-notes","title":"Additional notes","text":"<p>With this setup, <code>krossbow-stomp-core</code> is unnecessary because it's transitively brought by the <code>krossbow-stomp-kxserialization</code> modules.</p> <p>Note that Kotlinx Serialization also requires a compiler plugin to generate serializers for your <code>@Serializable</code> classes. See the Kotlinx Serialization doc for more information about this.</p>"},{"location":"stomp/conversions/moshi/","title":"STOMP with Moshi","text":"<p>The <code>krossbow-stomp-moshi</code> module is a JVM-only extension of <code>krossbow-stomp-core</code> that provides new APIs to send and receive properly typed classes, and automatically convert them to/from the JSON bodies of STOMP frames by leveraging Moshi.</p> <p>The main addition is the extension function <code>StompSession.withMoshi()</code>, which turns your <code>StompSession</code> into a <code>TypedStompSession</code>. This new session type has additional methods that use Moshi to convert your objects into JSON and back:</p> <pre><code>// example Moshi instance that converts Kotlin types using reflection\nval moshi = Moshi.Builder()\n.addLast(KotlinJsonAdapterFactory())\n.build()\nStompClient(WebSocketClient.builtIn()).connect(url).withMoshi(moshi).use { session -&gt;\nsession.convertAndSend(\"/some/destination\", Person(\"Bob\", 42)) val messages: Flow&lt;MyMessage&gt; = session.subscribe&lt;MyMessage&gt;(\"/some/topic/destination\")\nval firstMessage: MyMessage = messages.first()\n\nprintln(\"Received: $firstMessage\")\n}\n</code></pre>"},{"location":"stomp/conversions/moshi/#dependency","title":"Dependency","text":"<p>To use Moshi conversions, add <code>krossbow-stomp-moshi</code> to your Gradle dependencies (<code>krossbow-stomp-core</code> is unnecessary because it's transitively brought by this one):</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-stomp-moshi:5.7.0\")\n</code></pre> <p>This dependency transitively brings Moshi 1.15.0.</p>"},{"location":"websocket/builtin/","title":"Krossbow Web Socket Built-in","text":"<p>The <code>krossbow-websocket-builtin</code> module defines implementations of the <code>WebSocketClient</code> interface by adapting clients that already exist in each platform (without 3rd-party dependencies).</p> <p>For convenience in <code>common</code> source sets, this module also provides the builtIn() factory method, which returns the built-in implementation of the current platform.</p>"},{"location":"websocket/builtin/#jvm","title":"JVM","text":"<p>On the JVM target, the Jdk11WebSocketClient adapts the built-in HttpClient provided in the JRE since Java 11, and its WebSocket interface.</p> <p>Android not supported</p> <p>This adapter requires Java 11's <code>HttpClient</code> which is not available on Android. If you need to support Android, please use the OkHttp or Ktor adapter instead.</p>"},{"location":"websocket/builtin/#javascript","title":"JavaScript","text":"<p>On the JS target, the  BrowserWebSocketClient adapts the browser's built-in WebSocket directly.</p> <p>Also, the <code>JsWebSocketClientAdapter</code> allows to adapt anything that looks like the browser's <code>WebSocket</code>.</p>"},{"location":"websocket/builtin/#darwin-macos-ios-tvos-watchos","title":"Darwin (macOS, iOS, tvOS, watchOS)","text":"<p>On all Darwin targets, the  DarwinWebSocketClient adapts the Foundation framework's NSURLSessionWebSocketTask.</p>"},{"location":"websocket/builtin/#dependency-information","title":"Dependency information","text":"<p>To use the built-in web socket clients, add the following to your <code>build.gradle</code>:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-websocket-builtin:5.7.0\")\n</code></pre>"},{"location":"websocket/custom/","title":"Implement Krossbow's WebSocketClient yourself","text":"<p>The <code>krossbow-websocket-core</code> module defines a standard web socket API abstraction that is used by the STOMP artifacts and that you can also use directly if you're only interested in the web socket protocol without STOMP.</p> <p>Krossbow provides built-in implementations of the web socket interfaces in the <code>krossbow-websocket-builtin</code> module, but you can of course implement your own.</p>"},{"location":"websocket/custom/#basics","title":"Basics","text":"<p>You can create your own implementation of Krossbow's web socket client by implementing the WebSocketClient interface.</p> <p>This interface simply has a connect() method returning an instance of WebSocketConnection. The <code>WebSocketConnection</code> actually contains the bulk of the web socket interactions implementation.</p> <p>Please follow the KDoc of these interfaces to learn more about the contract that needs to be satisfied for each method.</p>"},{"location":"websocket/custom/#helpers","title":"Helpers","text":"<p>The <code>krossbow-websocket-core</code> module doesn't only provide interfaces to implement. It also provides some helper classes that help with most implementations of those interfaces.</p> <p>The WebSocketListenerFlowAdapter allows to adapt listener-based web socket APIs to Krossbow's <code>Flow</code> API easily. It takes care of partial message handling automatically, and can provide backpressure on the callback caller thanks to its <code>suspend</code> callbacks.</p> <p>The UnboundedWsListenerFlowAdapter also adapts listener-based APIs to Krossbow's flow, but without any backpressure support (functions are not <code>suspend</code> and return immediately). It adds new messages to an unbounded queue. This is necessary with some APIs like JS browsers <code>WebSocket</code> API, which cannot apply backpressure in any way on their web socket traffic.</p>"},{"location":"websocket/custom/#dependency-information","title":"Dependency information","text":"<p>Add the following to your <code>build.gradle(.kts)</code> in order to get the Krossbow's interfaces and helpers:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-websocket-core:5.7.0\")\n</code></pre>"},{"location":"websocket/ktor/","title":"Krossbow with Ktor","text":"<p>Krossbow allows you to use Ktor's web socket as transport for STOMP.</p> <p>Ktor's implementation supports a variety of platforms and is very popular in the Kotlin world, especially in Kotlin multiplatform.</p> <p>The <code>krossbow-websocket-ktor</code> module provides the <code>KtorWebSocketClient</code>, which adapts Ktor 2.3.4's <code>HttpClient</code> to Krossbow's web socket interface.</p>"},{"location":"websocket/ktor/#usage-with-stompclient","title":"Usage with StompClient","text":"<p>To use the <code>KtorWebSocketClient</code> pass an instance of it when creating your <code>StompClient</code>:</p> <pre><code>val client = StompClient(KtorWebSocketClient())\n</code></pre> <p>You can customize the actual Ktor HTTP client used behind the scenes by passing it to <code>KtorWebSocketClient</code>:</p> <pre><code>// You may configure Ktor HTTP client as you please,\n// but make sure at least the websocket feature is installed\nval httpClient = HttpClient {\ninstall(WebSockets)\n}\nval wsClient = KtorWebSocketClient(httpClient)\nval stompClient = StompClient(wsClient)\n</code></pre>"},{"location":"websocket/ktor/#dependency-information","title":"Dependency information","text":"<p>You will need to declare the following Gradle dependency to use the <code>KtorWebSocketClient</code>:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-websocket-ktor:5.7.0\")\n</code></pre> <p>Ktor uses pluggable engines to perform the platform-specific network operations (just like Krossbow uses different web socket implementations). You need to pick an engine that supports web sockets in order to use Ktor's <code>HttpClient</code> with web sockets. Follow Ktor's documentation to find out more about how to use engines.</p> <p>For instance, if you want to use Ktor's CIO engine with Krossbow, you need to declare the following:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-websocket-ktor:5.7.0\")\nimplementation(\"io.ktor:ktor-client-cio:2.3.4\")\n</code></pre>"},{"location":"websocket/okhttp/","title":"Krossbow with OkHttp","text":"<p>Krossbow allows you to use OkHttp's <code>WebSocket</code> as transport for STOMP.</p> <p>OkHttp is very popular on Android, and is already part of many projects as HTTP client of choice.</p> <p>The <code>krossbow-websocket-okhttp</code> module provides the <code>OkHttpWebSocketClient</code>, which adapts OkHttp's <code>WebSocket</code> to Krossbow's web socket interface.</p>"},{"location":"websocket/okhttp/#usage-with-stompclient","title":"Usage with StompClient","text":"<p>To use the <code>OkHttpWebSocketClient</code> pass an instance of it when creating your <code>StompClient</code>:</p> <pre><code>val client = StompClient(OkHttpWebSocketClient())\n</code></pre> <p>You can customize the actual <code>OkHttpClient</code> used behind the scenes by passing it to <code>OkHttpWebSocketClient()</code>:</p> <pre><code>// This allows to configure the underlying OkHttpClient as you please\n// (or use an existing one from your project)\nval okHttpClient = OkHttpClient.Builder()\n.callTimeout(Duration.ofMinutes(1))\n.pingInterval(Duration.ofSeconds(10))\n.build()\nval wsClient = OkHttpWebSocketClient(okHttpClient)\nval stompClient = StompClient(wsClient)\n</code></pre>"},{"location":"websocket/okhttp/#dependency-information","title":"Dependency information","text":"<p>You will need to declare the following Gradle dependency to use the <code>OkHttpWebSocketClient</code>:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-websocket-okhttp:5.7.0\")\n</code></pre>"},{"location":"websocket/sockjs/","title":"Krossbow with SockJS","text":"<p>Krossbow allows you to use SockJS-compatible clients as transport for STOMP.</p> <p>The <code>krossbow-websocket-sockjs</code> is a multiplatform facade implementing Krossbow's web socket interface by relying on different SockJS implementations. Here are the backing implementations for the different platforms:</p> <ul> <li>JS (browser and NodeJS): the <code>sockjs-client</code> library (isomorphic)</li> <li>JVM: Spring's <code>WebSocketClient</code> (with SockJS enabled), through <code>krossbow-websocket-spring</code></li> </ul> <p>Using a SockJS client requires a SockJS-enabled server.</p>"},{"location":"websocket/sockjs/#usage-with-stompclient","title":"Usage with StompClient","text":"<p>To use this client, just call <code>SockJSClient()</code> and the relevant platform-specific client will be instantiated for you:</p> <pre><code>val client = StompClient(SockJSClient())\n</code></pre>"},{"location":"websocket/sockjs/#dependency-information","title":"Dependency information","text":"<p>You will need to declare the following Gradle dependency to use the <code>SockJSClient</code>:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-websocket-sockjs:5.7.0\")\n</code></pre>"},{"location":"websocket/spring/","title":"Krossbow with Spring","text":"<p>Krossbow allows you to use Spring's <code>WebSocketClient</code> as transport for STOMP.</p> <p>The <code>krossbow-websocket-spring</code> module provides the <code>.asKrossbowWebSocketClient()</code> extension, which adapts any of Spring's <code>WebSocketClient</code> to Krossbow's web socket client interface.</p> <p>For example, use <code>StandardWebSocketClient().asKrossbowWebSocketClient()</code> to wrap Spring's standard JSR-356 client.</p>"},{"location":"websocket/spring/#usage-with-stompclient","title":"Usage with StompClient","text":"<p>To use a Spring web socket client with Krossbow's <code>StompClient</code>, adapt it to a Krossbow <code>WebSocketClient</code> using <code>.asKrossbowWebSocketClient()</code> and pass it to the <code>StompClient</code> constructor:</p> <pre><code>val stompClient = StompClient(StandardWebSocketClient().asKrossbowWebSocketClient())\n</code></pre> <p>You can of course further customize your Spring client before adapting it to Krossbow:</p> <pre><code>// Pure Spring configuration\nval springWsClient = StandardWebSocketClient().apply {\ntaskExecutor = SimpleAsyncTaskExecutor(\"my-websocket-threads\")\nuserProperties = mapOf(\"my-prop\" to \"someValue\")\n}\n\n// Krossbow adapter\nval stompClient = StompClient(springWsClient.asKrossbowWebSocketClient())\n</code></pre> <p>Another example of custom client, using Spring's SockJS client:</p> <pre><code>// Pure Spring configuration\nval transports = listOf(\nWebSocketTransport(StandardWebSocketClient()),\nRestTemplateXhrTransport(myCustomRestTemplate),\n)\nval springSockJsWsClient = SockJsClient(transports)\n\n// Krossbow adapter\nval stompClient = StompClient(springSockJsWsClient.asKrossbowWebSocketClient())\n</code></pre>"},{"location":"websocket/spring/#dependency-information","title":"Dependency information","text":"<p>You will need to declare the following Gradle dependency to use the Spring adapters:</p> <pre><code>implementation(\"org.hildan.krossbow:krossbow-websocket-spring:5.7.0\")\n</code></pre> <p>It transitively depends on <code>spring-websocket</code>, so you don't need to add it yourself.</p> <p>Important: if you're using Spring's <code>StandardWebSocketClient</code>, you'll also need to add a dependency on a JSR-356 implementation, such as the Tyrus reference implementation:</p> <pre><code>implementation(\"org.glassfish.tyrus.bundles:tyrus-standalone-client-jdk:2.1.3\")\n</code></pre>"}]}