{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Krossbow is a Kotlin multiplatform STOMP 1.2 client with a coroutine-based API. It is built on a web socket client abstraction, and provides a bunch of adapters for popular web socket clients (OkHttp, Ktor, Spring, SockJS...). It also provides out-of-the-box a built-in web socket implementation (without third-party dependencies) for most platforms (see below). Krossbow can also be used as a multiplatform web socket client without STOMP protocol. Features \u00b6 All the STOMP 1.2 specification is implemented: All STOMP frames, including ACK / NACK and transactions Text and binary bodies Receipts (waiting for RECEIPT frame based on receipt header) Heart beats (keep alive) Custom headers where the protocol allows them Additional features: Auto-receipts (automatically adds receipt headers to ensure no frame is lost) Built-in body conversions (Kotlinx Serialization or Jackson) Possibility to hook custom body converters (for textual or binary bodies) Automatic content length header for sent frames If you find a bug or a feature that's missing compared to the specification, please open an issue . Supported targets \u00b6 Krossbow supports most Kotlin targets in its STOMP and web socket API modules: JVM, JS (browser and nodeJS), iOS, watchOS, tvOS, macOSX64, linuxX64, mingwX64. However, each web socket client implementation has its own subset of supported targets (see below). Android not tested on CI Android 5.0+ (API level 21+) is supported by using JVM artifacts (e.g. OkHttp). However, the Android tooling's desugaring is currently not tested as part of the build, so any feedback on this use case is more than welcome. Please upvote the corresponding issue if you'd like to see proper CI or special packaging for the Android target. Web socket clients target support \u00b6 Krossbow can use built-in web socket implementations without third-party dependencies on some platforms. It also provides adapters for third-party implementations which have different platform support. Here is a summary of the supported platforms by module: Module Browser NodeJS JVM iOS / tvOS / watchOS macOS / Linux / Windows Transitive dependencies Built-in (JDK 11+) None Ktor 2 Ktor , and the relevant Ktor engine(s) Ktor 1.x Ktor , and the relevant Ktor engine(s) OkHttp OkHttp SockJS sockjs-client (on JS), Spring websocket (on JVM) Spring Spring websocket supported with actual web socket transport (RFC6455) supported using SockJS protocol (requires a SockJS server) Contribute \u00b6 Don't hesitate to open GitHub issues , even to ask questions or discuss a new feature. Pull-requests are welcome, but please open an issue first so that we can discuss the initial design or fix, which may avoid unnecessary work.","title":"Overview"},{"location":"#features","text":"All the STOMP 1.2 specification is implemented: All STOMP frames, including ACK / NACK and transactions Text and binary bodies Receipts (waiting for RECEIPT frame based on receipt header) Heart beats (keep alive) Custom headers where the protocol allows them Additional features: Auto-receipts (automatically adds receipt headers to ensure no frame is lost) Built-in body conversions (Kotlinx Serialization or Jackson) Possibility to hook custom body converters (for textual or binary bodies) Automatic content length header for sent frames If you find a bug or a feature that's missing compared to the specification, please open an issue .","title":"Features"},{"location":"#supported-targets","text":"Krossbow supports most Kotlin targets in its STOMP and web socket API modules: JVM, JS (browser and nodeJS), iOS, watchOS, tvOS, macOSX64, linuxX64, mingwX64. However, each web socket client implementation has its own subset of supported targets (see below). Android not tested on CI Android 5.0+ (API level 21+) is supported by using JVM artifacts (e.g. OkHttp). However, the Android tooling's desugaring is currently not tested as part of the build, so any feedback on this use case is more than welcome. Please upvote the corresponding issue if you'd like to see proper CI or special packaging for the Android target.","title":"Supported targets"},{"location":"#web-socket-clients-target-support","text":"Krossbow can use built-in web socket implementations without third-party dependencies on some platforms. It also provides adapters for third-party implementations which have different platform support. Here is a summary of the supported platforms by module: Module Browser NodeJS JVM iOS / tvOS / watchOS macOS / Linux / Windows Transitive dependencies Built-in (JDK 11+) None Ktor 2 Ktor , and the relevant Ktor engine(s) Ktor 1.x Ktor , and the relevant Ktor engine(s) OkHttp OkHttp SockJS sockjs-client (on JS), Spring websocket (on JVM) Spring Spring websocket supported with actual web socket transport (RFC6455) supported using SockJS protocol (requires a SockJS server)","title":"Web socket clients target support"},{"location":"#contribute","text":"Don't hesitate to open GitHub issues , even to ask questions or discuss a new feature. Pull-requests are welcome, but please open an issue first so that we can discuss the initial design or fix, which may avoid unnecessary work.","title":"Contribute"},{"location":"artifacts/","text":"Krossbow offers a lot of possibilities so here is a summary of all available artifacts. All these artifacts are published to Maven Central under the group ID org.hildan.krossbow and a common version. STOMP artifacts \u00b6 You should pick only one of the krossbow-stomp-* artifacts, depending on whether you need automatic serialization of frame bodies: Artifact Description krossbow-stomp-core The basic multiplatform STOMP client. It implements the STOMP 1.2 protocol on top of the web socket abstraction defined by the krossbow-websocket-core module. krossbow-stomp-default A superset of krossbow-stomp-core adding a StompClient constructor without web socket client argument, defaulting to the builtin implementations provided by krossbow-websocket-builtin (brought transitively) krossbow-stomp-jackson A superset of krossbow-stomp-core adding JSON conversion features using Jackson (JVM only) krossbow-stomp-kxserialization A superset of krossbow-stomp-core adding conversion features using Kotlinx Serialization library (multiplatform). You can leverage the multi-format capabilities of Kotlinx Serialization (JSON, protobuf, CBOR, ...). krossbow-stomp-kxserialization-json A superset of krossbow-stomp-kxserialization adding JSON helpers and the JSON format dependency. Then add the dependency of your choice to your Gradle build. For instance, if you intend to use Krossbow with Kotlinx Serialization: implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:4.0.0\" ) Don't need STOMP? If you're just interested in the web socket client without STOMP protocol, don't declare a STOMP artifact, but instead choose either: the built-in web socket implementation (without third-party dependencies) a third party web socket implementation (see below) Web Socket artifacts \u00b6 The STOMP artifacts depend on a web socket API that needs an implementation. Krossbow provides implementations for the built-in web socket API of most platforms, and also adapters for 3rd-part web socket implementations: Artifact Description krossbow-websocket-builtin A multiplatform WebSocketClient implementation that adapts the built-in client for each supported platform without transitive dependency. krossbow-websocket-ktor A multiplatform WebSocketClient implementation based on Ktor 2.0.2's HttpClient . krossbow-websocket-ktor-legacy A multiplatform WebSocketClient implementation based on Ktor 1.6.8's HttpClient . krossbow-websocket-okhttp A JVM implementation of the web socket API using OkHttp's client. krossbow-websocket-sockjs A multiplatform WebSocketClient implementation for use with SockJS servers. It uses Spring's SockJSClient on JVM, and npm sockjs-client for JavaScript (NodeJS and browser). krossbow-websocket-spring A JVM 8+ implementation of the web socket API using Spring's WebSocketClient. Provides both a normal WebSocket client and a SockJS one. Peer dependencies Some Krossbow modules are not opinionated and require some extra third-party peer dependencies. Make sure to read the usage section corresponding to the module of your choice for more details.","title":"Artifacts summary"},{"location":"artifacts/#stomp-artifacts","text":"You should pick only one of the krossbow-stomp-* artifacts, depending on whether you need automatic serialization of frame bodies: Artifact Description krossbow-stomp-core The basic multiplatform STOMP client. It implements the STOMP 1.2 protocol on top of the web socket abstraction defined by the krossbow-websocket-core module. krossbow-stomp-default A superset of krossbow-stomp-core adding a StompClient constructor without web socket client argument, defaulting to the builtin implementations provided by krossbow-websocket-builtin (brought transitively) krossbow-stomp-jackson A superset of krossbow-stomp-core adding JSON conversion features using Jackson (JVM only) krossbow-stomp-kxserialization A superset of krossbow-stomp-core adding conversion features using Kotlinx Serialization library (multiplatform). You can leverage the multi-format capabilities of Kotlinx Serialization (JSON, protobuf, CBOR, ...). krossbow-stomp-kxserialization-json A superset of krossbow-stomp-kxserialization adding JSON helpers and the JSON format dependency. Then add the dependency of your choice to your Gradle build. For instance, if you intend to use Krossbow with Kotlinx Serialization: implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:4.0.0\" ) Don't need STOMP? If you're just interested in the web socket client without STOMP protocol, don't declare a STOMP artifact, but instead choose either: the built-in web socket implementation (without third-party dependencies) a third party web socket implementation (see below)","title":"STOMP artifacts"},{"location":"artifacts/#web-socket-artifacts","text":"The STOMP artifacts depend on a web socket API that needs an implementation. Krossbow provides implementations for the built-in web socket API of most platforms, and also adapters for 3rd-part web socket implementations: Artifact Description krossbow-websocket-builtin A multiplatform WebSocketClient implementation that adapts the built-in client for each supported platform without transitive dependency. krossbow-websocket-ktor A multiplatform WebSocketClient implementation based on Ktor 2.0.2's HttpClient . krossbow-websocket-ktor-legacy A multiplatform WebSocketClient implementation based on Ktor 1.6.8's HttpClient . krossbow-websocket-okhttp A JVM implementation of the web socket API using OkHttp's client. krossbow-websocket-sockjs A multiplatform WebSocketClient implementation for use with SockJS servers. It uses Spring's SockJSClient on JVM, and npm sockjs-client for JavaScript (NodeJS and browser). krossbow-websocket-spring A JVM 8+ implementation of the web socket API using Spring's WebSocketClient. Provides both a normal WebSocket client and a SockJS one. Peer dependencies Some Krossbow modules are not opinionated and require some extra third-party peer dependencies. Make sure to read the usage section corresponding to the module of your choice for more details.","title":"Web Socket artifacts"},{"location":"license/","text":"MIT License \u00b6 Copyright (c) 2019-2021 Joffrey Bion Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#mit-license","text":"Copyright (c) 2019-2021 Joffrey Bion Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"migration-guides/","text":"Here are some details about how to migrate from one major version to another. From 3.x to 4.x \u00b6 withJsonConversions moved to its own module \u00b6 If you were using Krossbow with krossbow-stomp-kxserialization , the withJsonConversions helper has moved to a new module called krossbow-stomp-kxserialization-json . This new module now transitively brings kotlinx-serialization-json so you don't need to depend on that one explicitly. Built-in web socket clients and default StompClient constructor moved to their own module \u00b6 Up to (and including) version 3.x of Krossbow, the built-in web socket clients for the supported platforms were part of the krossbow-websocket-core module. This module provided a WebSocketClient.Companion.default() factory function to provide the built-in web socket implementation of the current platform. Likewise, the krossbow-stomp-core module provided a StompClient constructor that used the \"default\" built-in web socket implementation for the current platform. This approach limited the targets supported by those 2 core modules, even though all of their functionality was target-agnostic. In order to support all Kotlin platforms in pure Kotlin modules, the built-in websocket implementations and no-arg StompClient constructor had to be moved to separate modules. Breaking dependency changes, in short: if you used the StompClient() constructor without WS client argument (using the default value), simply declare a dependency on krossbow-stomp-default instead of krossbow-stomp-core , or in addition to another STOMP artifact. if you used WebSocketClient.default() from krossbow-websocket-core , or any of the built-in clients directly, simply change your dependency to krossbow-websocket-builtin instead If you used other web socket implementations than the built-in ones, you don't have to change anything to your dependencies. From 2.x to 3.x \u00b6 Use Durations instead of millis \u00b6 StompConfiguration no longer uses amounts of milliseconds, but uses the kotlin.time.Duration API. The -Millis suffixes for the relevant properties were therefore dropped and the types changed. Before: val stomp = StompClient { connectionTimeoutMillis = 2000 receiptTimeoutMillis = 5000 disconnectTimeoutMillis = 300 } After: import kotlin.time.Duration.Companion.milliseconds import kotlin.time.Duration.Companion.seconds val stomp = StompClient { connectionTimeout = 2. seconds receiptTimeout = 5. seconds disconnectTimeout = 300. milliseconds } Flow instead of Channel in WebSocketConnection \u00b6 If you used the websocket API directly, the incomingFrames channel is now a Flow . Before: val conn = wsClient . connect ( url ) for ( frame in conn . incomingFrames ) { // do stuff } After: val conn = wsClient . connect ( url ) conn . incomingFrames . collect { // do stuff } Tyrus no longer embedded in krossbow-websocket-spring \u00b6 krossbow-websocket-spring no longer transitively brings a dependency on Tyrus. If you didn't add any JSR-356 implementation manually, you now have to explicitly depend on one. If you want the same behaviour as before, add the Tyrus dependency to your build.gradle.kts as follows: dependencies { implementation(\"org.glassfish.tyrus.bundles:tyrus-standalone-client-jdk:1.17\") } From 1.x to 2.x \u00b6 StompSession.use now passes the session as it , not this \u00b6 In order to align with Closeable.use , the lambda for StompSession.use now receives the session as an argument ( it ) and not receiver ( this ). Before: StompClient (). connect ( url ). use { sendText ( \"/dest\" , \"message\" ) } After: StompClient (). connect ( url ). use { it . sendText ( \"/dest\" , \"message\" ) } // or StompClient (). connect ( url ). use { session -> session . sendText ( \"/dest\" , \"message\" ) }","title":"Migration guides"},{"location":"migration-guides/#from-3x-to-4x","text":"","title":"From 3.x to 4.x"},{"location":"migration-guides/#withjsonconversions-moved-to-its-own-module","text":"If you were using Krossbow with krossbow-stomp-kxserialization , the withJsonConversions helper has moved to a new module called krossbow-stomp-kxserialization-json . This new module now transitively brings kotlinx-serialization-json so you don't need to depend on that one explicitly.","title":"withJsonConversions moved to its own module"},{"location":"migration-guides/#built-in-web-socket-clients-and-default-stompclient-constructor-moved-to-their-own-module","text":"Up to (and including) version 3.x of Krossbow, the built-in web socket clients for the supported platforms were part of the krossbow-websocket-core module. This module provided a WebSocketClient.Companion.default() factory function to provide the built-in web socket implementation of the current platform. Likewise, the krossbow-stomp-core module provided a StompClient constructor that used the \"default\" built-in web socket implementation for the current platform. This approach limited the targets supported by those 2 core modules, even though all of their functionality was target-agnostic. In order to support all Kotlin platforms in pure Kotlin modules, the built-in websocket implementations and no-arg StompClient constructor had to be moved to separate modules. Breaking dependency changes, in short: if you used the StompClient() constructor without WS client argument (using the default value), simply declare a dependency on krossbow-stomp-default instead of krossbow-stomp-core , or in addition to another STOMP artifact. if you used WebSocketClient.default() from krossbow-websocket-core , or any of the built-in clients directly, simply change your dependency to krossbow-websocket-builtin instead If you used other web socket implementations than the built-in ones, you don't have to change anything to your dependencies.","title":"Built-in web socket clients and default StompClient constructor moved to their own module"},{"location":"migration-guides/#from-2x-to-3x","text":"","title":"From 2.x to 3.x"},{"location":"migration-guides/#use-durations-instead-of-millis","text":"StompConfiguration no longer uses amounts of milliseconds, but uses the kotlin.time.Duration API. The -Millis suffixes for the relevant properties were therefore dropped and the types changed. Before: val stomp = StompClient { connectionTimeoutMillis = 2000 receiptTimeoutMillis = 5000 disconnectTimeoutMillis = 300 } After: import kotlin.time.Duration.Companion.milliseconds import kotlin.time.Duration.Companion.seconds val stomp = StompClient { connectionTimeout = 2. seconds receiptTimeout = 5. seconds disconnectTimeout = 300. milliseconds }","title":"Use Durations instead of millis"},{"location":"migration-guides/#flow-instead-of-channel-in-websocketconnection","text":"If you used the websocket API directly, the incomingFrames channel is now a Flow . Before: val conn = wsClient . connect ( url ) for ( frame in conn . incomingFrames ) { // do stuff } After: val conn = wsClient . connect ( url ) conn . incomingFrames . collect { // do stuff }","title":"Flow instead of Channel in WebSocketConnection"},{"location":"migration-guides/#tyrus-no-longer-embedded-in-krossbow-websocket-spring","text":"krossbow-websocket-spring no longer transitively brings a dependency on Tyrus. If you didn't add any JSR-356 implementation manually, you now have to explicitly depend on one. If you want the same behaviour as before, add the Tyrus dependency to your build.gradle.kts as follows: dependencies { implementation(\"org.glassfish.tyrus.bundles:tyrus-standalone-client-jdk:1.17\") }","title":"Tyrus no longer embedded in krossbow-websocket-spring"},{"location":"migration-guides/#from-1x-to-2x","text":"","title":"From 1.x to 2.x"},{"location":"migration-guides/#stompsessionuse-now-passes-the-session-as-it-not-this","text":"In order to align with Closeable.use , the lambda for StompSession.use now receives the session as an argument ( it ) and not receiver ( this ). Before: StompClient (). connect ( url ). use { sendText ( \"/dest\" , \"message\" ) } After: StompClient (). connect ( url ). use { it . sendText ( \"/dest\" , \"message\" ) } // or StompClient (). connect ( url ). use { session -> session . sendText ( \"/dest\" , \"message\" ) }","title":"StompSession.use now passes the session as it, not this"},{"location":"stomp/advanced-features/","text":"Receipts & Suspension \u00b6 The STOMP protocol supports RECEIPT frames, allowing the client to know when the server has received a frame. This only happens if a receipt header is set on the client frame. If auto-receipt is enabled, a receipt header is automatically generated and added to all client frames supporting the mechanism, and for which a receipt header is not already present. If auto-receipt is not enabled, a receipt header may still be provided manually in the parameters of some overloads. When a receipt header is present (automatically added or manually provided), the method that is used to send the frame suspends until the corresponding RECEIPT frame is received from the server. If no RECEIPT frame is received from the server in the configured time limit , a LostReceiptException is thrown. If no receipt is provided and auto-receipt is disabled, the method used to send the frame doesn't wait for a RECEIPT frame and never throws LostReceiptException . Instead, it returns immediately after the underlying web socket implementation is done sending the frame. Heart beats \u00b6 When configured, heart beats can be used as a keep-alive to detect if the connection is lost. The heartBeat property should be used to configure heart beats in the StompClient . Note that the heart beats for the STOMP session are negotiated with the server. The actual heart beats are defined by the CONNECTED frame received from the server as a result of the negotiation, and may differ from the StompClient configuration. The negotiation behaviour is defined by the specification . Sending and checking heart beats is automatically handled by StompSession implementations, depending on the result of the negotiation with the server. If expected heart beats are not received in time, a MissingHeartBeatException is thrown and fails active subscriptions. Graceful disconnect \u00b6 The graceful disconnect (or graceful shutdown) is a disconnection procedure defined by the STOMP specification to make sure the server gets all the frames before dropping the connection. If enabled in the config , when disconnecting from the server, the client first sends a DISCONNECT frame with a receipt header, and then waits for a RECEIPT frame before closing the connection. If this graceful disconnect is disabled, then calling StompSession.disconnect() immediately closes the web socket connection. In this case, there is no guarantee that the server received all previous messages.","title":"Advanced features"},{"location":"stomp/advanced-features/#receipts-suspension","text":"The STOMP protocol supports RECEIPT frames, allowing the client to know when the server has received a frame. This only happens if a receipt header is set on the client frame. If auto-receipt is enabled, a receipt header is automatically generated and added to all client frames supporting the mechanism, and for which a receipt header is not already present. If auto-receipt is not enabled, a receipt header may still be provided manually in the parameters of some overloads. When a receipt header is present (automatically added or manually provided), the method that is used to send the frame suspends until the corresponding RECEIPT frame is received from the server. If no RECEIPT frame is received from the server in the configured time limit , a LostReceiptException is thrown. If no receipt is provided and auto-receipt is disabled, the method used to send the frame doesn't wait for a RECEIPT frame and never throws LostReceiptException . Instead, it returns immediately after the underlying web socket implementation is done sending the frame.","title":"Receipts &amp; Suspension"},{"location":"stomp/advanced-features/#heart-beats","text":"When configured, heart beats can be used as a keep-alive to detect if the connection is lost. The heartBeat property should be used to configure heart beats in the StompClient . Note that the heart beats for the STOMP session are negotiated with the server. The actual heart beats are defined by the CONNECTED frame received from the server as a result of the negotiation, and may differ from the StompClient configuration. The negotiation behaviour is defined by the specification . Sending and checking heart beats is automatically handled by StompSession implementations, depending on the result of the negotiation with the server. If expected heart beats are not received in time, a MissingHeartBeatException is thrown and fails active subscriptions.","title":"Heart beats"},{"location":"stomp/advanced-features/#graceful-disconnect","text":"The graceful disconnect (or graceful shutdown) is a disconnection procedure defined by the STOMP specification to make sure the server gets all the frames before dropping the connection. If enabled in the config , when disconnecting from the server, the client first sends a DISCONNECT frame with a receipt header, and then waits for a RECEIPT frame before closing the connection. If this graceful disconnect is disabled, then calling StompSession.disconnect() immediately closes the web socket connection. In this case, there is no guarantee that the server received all previous messages.","title":"Graceful disconnect"},{"location":"stomp/config/","text":"Configuring the StompClient \u00b6 The StompClient can be configured at construction time using a convenient lambda block: val stompClient = StompClient { connectionTimeout = 3. seconds gracefulDisconnect = false } You can also create the configuration separately and then pass it when constructing the client: val stompConfig = StompConfig (). apply { connectionTimeout = 3. seconds gracefulDisconnect = false } val stompClient = StompClient ( config = stompConfig ) Configuration options \u00b6 You can find out about all configuration properties in the StompConfig KDoc . autoReceipt (default: false) Whether to automatically attach a receipt header to the sent frames in order to track receipts. autoContentLength (default: true) Whether to automatically compute and add the content-length header in sent frames. connectWithStompCommand (default: false) Whether to use the STOMP command instead of CONNECT to establish the connection. Clients that use the STOMP frame instead of the CONNECT frame will only be able to connect to STOMP 1.2 servers (as well as some STOMP 1.1 servers) but the advantage is that a protocol sniffer/discriminator will be able to differentiate the STOMP connection from an HTTP connection. heartBeat (default: none) The heart beats to request for the STOMP sessions. This is part of a negotiation and does not imply that this exact heart beat configuration will be used. The actual heart beats are defined by the CONNECTED frame received from the server as a result of the negotiation. This behaviour is defined by the specification . heartBeatTolerance (default: none) Defines tolerance for heart beats. If both the client and server really stick to the heart beats periods negotiated and given by the CONNECTED frame, network latencies will make them miss their marks. That's why we need some sort of tolerance. In case the server is too strict about its expectations, we can send heart beats a little bit earlier than we're supposed to (see HeartBeatTolerance.outgoingMargin ). In case the server really sticks to its own period without such margin, we need to allow a little bit of delay to make up for network latencies before we fail and close the connection (see HeartBeatTolerance.incomingMargin ). connectionTimeout (default: 15s) Defines how long to wait for the websocket+STOMP connection to be established before throwing an exception. receiptTimeout (default: 1s) Defines how long to wait for a RECEIPT frame from the server before throwing a LostReceiptException . Only crashes when a receipt header was actually present in the sent frame (and thus a RECEIPT was expected). Such header is always present if autoReceipt is enabled. Note that this doesn't apply to the DISCONNECT frames, use disconnectTimeout instead for that. disconnectTimeout (default: 200ms) Like receiptTimeout but only for the receipt of the DISCONNECT frame. This is ignored if gracefulDisconnect is disabled. Note that if this timeout expires, the [StompSession.disconnect] call doesn't throw an exception. This is to allow servers to close the connection quickly (sometimes too quick for sending a RECEIPT/ERROR) as mentioned in the specification . gracefulDisconnect (default: true) Enables graceful disconnect . If enabled, when disconnecting from the server, the client first sends a DISCONNECT frame with a receipt header, and then waits for a RECEIPT frame before closing the connection. If this graceful disconnect is disabled, then calling [StompSession.disconnect] immediately closes the web socket connection. In this case, there is no guarantee that the server received all previous messages. instrumentation A set of hooks that are called in different places of the internal execution of Krossbow. The instrumentation can be used for monitoring, logging or debugging purposes.","title":"Configuration"},{"location":"stomp/config/#configuring-the-stompclient","text":"The StompClient can be configured at construction time using a convenient lambda block: val stompClient = StompClient { connectionTimeout = 3. seconds gracefulDisconnect = false } You can also create the configuration separately and then pass it when constructing the client: val stompConfig = StompConfig (). apply { connectionTimeout = 3. seconds gracefulDisconnect = false } val stompClient = StompClient ( config = stompConfig )","title":"Configuring the StompClient"},{"location":"stomp/config/#configuration-options","text":"You can find out about all configuration properties in the StompConfig KDoc . autoReceipt (default: false) Whether to automatically attach a receipt header to the sent frames in order to track receipts. autoContentLength (default: true) Whether to automatically compute and add the content-length header in sent frames. connectWithStompCommand (default: false) Whether to use the STOMP command instead of CONNECT to establish the connection. Clients that use the STOMP frame instead of the CONNECT frame will only be able to connect to STOMP 1.2 servers (as well as some STOMP 1.1 servers) but the advantage is that a protocol sniffer/discriminator will be able to differentiate the STOMP connection from an HTTP connection. heartBeat (default: none) The heart beats to request for the STOMP sessions. This is part of a negotiation and does not imply that this exact heart beat configuration will be used. The actual heart beats are defined by the CONNECTED frame received from the server as a result of the negotiation. This behaviour is defined by the specification . heartBeatTolerance (default: none) Defines tolerance for heart beats. If both the client and server really stick to the heart beats periods negotiated and given by the CONNECTED frame, network latencies will make them miss their marks. That's why we need some sort of tolerance. In case the server is too strict about its expectations, we can send heart beats a little bit earlier than we're supposed to (see HeartBeatTolerance.outgoingMargin ). In case the server really sticks to its own period without such margin, we need to allow a little bit of delay to make up for network latencies before we fail and close the connection (see HeartBeatTolerance.incomingMargin ). connectionTimeout (default: 15s) Defines how long to wait for the websocket+STOMP connection to be established before throwing an exception. receiptTimeout (default: 1s) Defines how long to wait for a RECEIPT frame from the server before throwing a LostReceiptException . Only crashes when a receipt header was actually present in the sent frame (and thus a RECEIPT was expected). Such header is always present if autoReceipt is enabled. Note that this doesn't apply to the DISCONNECT frames, use disconnectTimeout instead for that. disconnectTimeout (default: 200ms) Like receiptTimeout but only for the receipt of the DISCONNECT frame. This is ignored if gracefulDisconnect is disabled. Note that if this timeout expires, the [StompSession.disconnect] call doesn't throw an exception. This is to allow servers to close the connection quickly (sometimes too quick for sending a RECEIPT/ERROR) as mentioned in the specification . gracefulDisconnect (default: true) Enables graceful disconnect . If enabled, when disconnecting from the server, the client first sends a DISCONNECT frame with a receipt header, and then waits for a RECEIPT frame before closing the connection. If this graceful disconnect is disabled, then calling [StompSession.disconnect] immediately closes the web socket connection. In this case, there is no guarantee that the server received all previous messages. instrumentation A set of hooks that are called in different places of the internal execution of Krossbow. The instrumentation can be used for monitoring, logging or debugging purposes.","title":"Configuration options"},{"location":"stomp/getting-started/","text":"To quickly get started and use the built-in web socket clients, add the following Gradle dependency to your build.gradle(.kts) : implementation ( \"org.hildan.krossbow:krossbow-stomp-default:4.0.0\" ) You can find more info about more advanced configuration below . Basic usage (without body conversions) \u00b6 This is how to create a STOMP client and interact with it: import kotlinx.coroutines.flow.* import org.hildan.krossbow.stomp.* val client = StompClient () // custom WebSocketClient and other config can be passed in here val session : StompSession = client . connect ( url ) // optional login/passcode can be provided here session . sendText ( \"/some/destination\" , \"Basic text message\" ) // this triggers a SUBSCRIBE frame and returns the flow of messages for the subscription val subscription : Flow < String > = session . subscribeText ( \"/some/topic/destination\" ) val collectorJob = launch { subscription . collect { msg -> println ( \"Received: $ msg \" ) } } delay ( 3000 ) // cancelling the flow collector triggers an UNSUBSCRIBE frame collectorJob . cancel () session . disconnect () If you want to disconnect automatically in case of exception or normal termination, you can use a try / finally block, or use StompSession.use() , which is similar to Closeable.use() : import kotlinx.coroutines.flow.* import org.hildan.krossbow.stomp.* val client = StompClient () // custom WebSocketClient and other config can be passed in here val session : StompSession = client . connect ( url ) // optional login/passcode can be provided here session . use { s -> s . sendText ( \"/some/destination\" , \"Basic text message\" ) val subscription : Flow < String > = s . subscribeText ( \"/some/topic/destination\" ) // terminal operators that finish early (like first) also trigger UNSUBSCRIBE automatically val firstMessage : String = subscription . first () println ( \"Received: $ firstMessage \" ) } // DISCONNECT frame was automatically sent at the end of the use{...} block Using body conversions \u00b6 You can use STOMP with basic text as frame bodies, but it really becomes interesting when you can convert the frame bodies back and forth into Kotlin objects. Check out the following sections to see how to automatically convert your objects into STOMP frame bodies: using Kotlinx Serialization (multiplatform) using Jackson (JVM-only) using Moshi (JVM-only) using custom conversions Gradle setup \u00b6 Using the built-in web socket clients \u00b6 For the basic usage of STOMP with the built-in web socket clients, you only need the following Gradle dependency: implementation ( \"org.hildan.krossbow:krossbow-stomp-default:4.0.0\" ) This provides a StompClient() constructor that will automatically use the built-in web socket client for the current platform. If you want to use STOMP body conversions to serialize/deserialize objects directly into/from STOMP frames, add the relevant conversion module. For instance, to use Kotlinx Serialization: implementation ( \"org.hildan.krossbow:krossbow-stomp-default:4.0.0\" ) implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:4.0.0\" ) Using third-party web socket clients \u00b6 If you want to use another web socket client, declare both the core STOMP artifact and the specific web socket artifact. For example, if you want to use Krossbow with Ktor web socket client: implementation ( \"org.hildan.krossbow:krossbow-stomp-core:4.0.0\" ) implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:4.0.0\" ) This way you can call the StompClient constructor with the web socket client of your choice (e.g. StompClient(KtorWebSocketClient()) ). If you want to use STOMP body conversions to serialize/deserialize objects directly into/from STOMP frames, replace the krossbow-stomp-core module with the relevant conversion module. For instance, to use Kotlinx Serialization: implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:4.0.0\" ) implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:4.0.0\" )","title":"Getting started"},{"location":"stomp/getting-started/#basic-usage-without-body-conversions","text":"This is how to create a STOMP client and interact with it: import kotlinx.coroutines.flow.* import org.hildan.krossbow.stomp.* val client = StompClient () // custom WebSocketClient and other config can be passed in here val session : StompSession = client . connect ( url ) // optional login/passcode can be provided here session . sendText ( \"/some/destination\" , \"Basic text message\" ) // this triggers a SUBSCRIBE frame and returns the flow of messages for the subscription val subscription : Flow < String > = session . subscribeText ( \"/some/topic/destination\" ) val collectorJob = launch { subscription . collect { msg -> println ( \"Received: $ msg \" ) } } delay ( 3000 ) // cancelling the flow collector triggers an UNSUBSCRIBE frame collectorJob . cancel () session . disconnect () If you want to disconnect automatically in case of exception or normal termination, you can use a try / finally block, or use StompSession.use() , which is similar to Closeable.use() : import kotlinx.coroutines.flow.* import org.hildan.krossbow.stomp.* val client = StompClient () // custom WebSocketClient and other config can be passed in here val session : StompSession = client . connect ( url ) // optional login/passcode can be provided here session . use { s -> s . sendText ( \"/some/destination\" , \"Basic text message\" ) val subscription : Flow < String > = s . subscribeText ( \"/some/topic/destination\" ) // terminal operators that finish early (like first) also trigger UNSUBSCRIBE automatically val firstMessage : String = subscription . first () println ( \"Received: $ firstMessage \" ) } // DISCONNECT frame was automatically sent at the end of the use{...} block","title":"Basic usage (without body conversions)"},{"location":"stomp/getting-started/#using-body-conversions","text":"You can use STOMP with basic text as frame bodies, but it really becomes interesting when you can convert the frame bodies back and forth into Kotlin objects. Check out the following sections to see how to automatically convert your objects into STOMP frame bodies: using Kotlinx Serialization (multiplatform) using Jackson (JVM-only) using Moshi (JVM-only) using custom conversions","title":"Using body conversions"},{"location":"stomp/getting-started/#gradle-setup","text":"","title":"Gradle setup"},{"location":"stomp/getting-started/#using-the-built-in-web-socket-clients","text":"For the basic usage of STOMP with the built-in web socket clients, you only need the following Gradle dependency: implementation ( \"org.hildan.krossbow:krossbow-stomp-default:4.0.0\" ) This provides a StompClient() constructor that will automatically use the built-in web socket client for the current platform. If you want to use STOMP body conversions to serialize/deserialize objects directly into/from STOMP frames, add the relevant conversion module. For instance, to use Kotlinx Serialization: implementation ( \"org.hildan.krossbow:krossbow-stomp-default:4.0.0\" ) implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:4.0.0\" )","title":"Using the built-in web socket clients"},{"location":"stomp/getting-started/#using-third-party-web-socket-clients","text":"If you want to use another web socket client, declare both the core STOMP artifact and the specific web socket artifact. For example, if you want to use Krossbow with Ktor web socket client: implementation ( \"org.hildan.krossbow:krossbow-stomp-core:4.0.0\" ) implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:4.0.0\" ) This way you can call the StompClient constructor with the web socket client of your choice (e.g. StompClient(KtorWebSocketClient()) ). If you want to use STOMP body conversions to serialize/deserialize objects directly into/from STOMP frames, replace the krossbow-stomp-core module with the relevant conversion module. For instance, to use Kotlinx Serialization: implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:4.0.0\" ) implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:4.0.0\" )","title":"Using third-party web socket clients"},{"location":"stomp/conversions/custom/","text":"If you want to use your own text conversion, you can implement TextMessageConverter without any additional module, and use withTextConversions to wrap your StompSession into a TypedStompSession . Limited JS support Reflection-based conversions may behave poorly on the JS platform. It is usually safer to rely on Kotlinx Serialization for multiplatform conversions. val myConverter = object : TextMessageConverter { override val mimeType : String = \"application/json;charset=utf-8\" override fun < T > convertToString ( value : T , type : KTypeRef < T > ): String { TODO ( \"your own object -> text conversion\" ) } override fun < T > convertFromString ( text : String , type : KTypeRef < T > ): T { TODO ( \"your own text -> object conversion\" ) } } StompClient (). connect ( url ). withTextConversions ( myConverter ). use { session -> session . convertAndSend ( \"/some/destination\" , MyPojo ( \"Custom\" , 42 )) val messages = session . subscribe < MyMessage > ( \"/some/topic/destination\" ) val firstMessage : MyMessage = messages . first () println ( \"Received: $ firstMessage \" ) }","title":"Custom conversions"},{"location":"stomp/conversions/jackson/","text":"STOMP with Jackson \u00b6 The krossbow-stomp-jackson module is a JVM-only extension of krossbow-stomp-core that provides new APIs to send and receive properly typed classes, and automatically convert them to/from the JSON bodies of STOMP frames by leveraging Jackson and jackson-module-kotlin . The main addition is the extension function StompSession.withJackson() , which turns your StompSession into a TypedStompSession . This new session type has additional methods that use Jackson to convert your objects into JSON and back: StompClient (). connect ( url ). withJackson (). use { session -> session . convertAndSend ( \"/some/destination\" , Person ( \"Bob\" , 42 )) val messages : Flow < MyMessage > = session . subscribe < MyMessage > ( \"/some/topic/destination\" ) val firstMessage : MyMessage = messages . first () println ( \"Received: $ firstMessage \" ) } Using a custom ObjectMapper \u00b6 Jackson is highly configurable, and it's often useful to configure the ObjectMapper manually. The withJackson() method takes an optional ObjectMapper parameter, so you can configure it as you please: val customObjectMapper : ObjectMapper = jacksonObjectMapper () . disable ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) . disable ( DeserializationFeature . FAIL_ON_IGNORED_PROPERTIES ) . enable ( SerializationFeature . ORDER_MAP_ENTRIES_BY_KEYS ) val client = StompClient (). connect ( url ) val session = client . withJacksonConversions ( customObjectMapper ) Dependency \u00b6 You will need to declare the following Gradle dependency to add these capabilities (you don't need the core module anymore as it is transitively brought by this one): implementation ( \"org.hildan.krossbow:krossbow-stomp-jackson:4.0.0\" ) This dependency transitively brings Jackson 2.13.3 with the Kotlin module .","title":"Jackson"},{"location":"stomp/conversions/jackson/#stomp-with-jackson","text":"The krossbow-stomp-jackson module is a JVM-only extension of krossbow-stomp-core that provides new APIs to send and receive properly typed classes, and automatically convert them to/from the JSON bodies of STOMP frames by leveraging Jackson and jackson-module-kotlin . The main addition is the extension function StompSession.withJackson() , which turns your StompSession into a TypedStompSession . This new session type has additional methods that use Jackson to convert your objects into JSON and back: StompClient (). connect ( url ). withJackson (). use { session -> session . convertAndSend ( \"/some/destination\" , Person ( \"Bob\" , 42 )) val messages : Flow < MyMessage > = session . subscribe < MyMessage > ( \"/some/topic/destination\" ) val firstMessage : MyMessage = messages . first () println ( \"Received: $ firstMessage \" ) }","title":"STOMP with Jackson"},{"location":"stomp/conversions/jackson/#using-a-custom-objectmapper","text":"Jackson is highly configurable, and it's often useful to configure the ObjectMapper manually. The withJackson() method takes an optional ObjectMapper parameter, so you can configure it as you please: val customObjectMapper : ObjectMapper = jacksonObjectMapper () . disable ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) . disable ( DeserializationFeature . FAIL_ON_IGNORED_PROPERTIES ) . enable ( SerializationFeature . ORDER_MAP_ENTRIES_BY_KEYS ) val client = StompClient (). connect ( url ) val session = client . withJacksonConversions ( customObjectMapper )","title":"Using a custom ObjectMapper"},{"location":"stomp/conversions/jackson/#dependency","text":"You will need to declare the following Gradle dependency to add these capabilities (you don't need the core module anymore as it is transitively brought by this one): implementation ( \"org.hildan.krossbow:krossbow-stomp-jackson:4.0.0\" ) This dependency transitively brings Jackson 2.13.3 with the Kotlin module .","title":"Dependency"},{"location":"stomp/conversions/kx-serialization/","text":"STOMP with Kotlinx Serialization \u00b6 Kotlinx Serialization is a multiplatform and multi-format serialization library provided by the Kotlin team. It is a popular choice for Kotlin multiplatform libraries especially because of its extensive support of Kotlin features. The krossbow-stomp-kxserialization module is an extension of krossbow-stomp-core that provides new APIs to send and receive properly typed classes, and automatically convert STOMP frame bodies by leveraging Kotlinx Serialization. A note on JSON format \u00b6 Since Kotlinx Serialization supports multiple formats with different dependencies, you have to add your own dependency to bring the format of your choice. However, since JSON is so popular, Krossbow comes with the krossbow-stomp-kxserialization-json module, which adds dedicated helpers for JSON and the necessary transitive dependency on the JSON format. Basic usage \u00b6 This module brings the following extension functions on StompSession : withBinaryConversions(format: BinaryFormat, mediaType: String) withTextConversions(format: StringFormat, mediaType: String) JSON convenience If you're using JSON, a dedicated withJsonConversions helper for JSON serialization is provided in the krossbow-stomp-serialization-json module. These helpers turn your StompSession into a StompSessionWithKxSerialization . This new session type has additional methods that use Kotlinx Serialization's serializers to serialize/deserialize your objects using the format of your choice (JSON, protobuf, etc.). You can for instance use convertAndSend and subscribe overloads with serializers like this: import org.hildan.krossbow.stomp.* import org.hildan.krossbow.stomp.conversions.kxserialization.* @Serializable data class Person ( val name : String , val age : Int ) @Serializable data class MyMessage ( val timestamp : Long , val author : String , val content : String ) val session = StompClient (). connect ( url ) val jsonStompSession = session . withJsonConversions () // adds convenience methods for kotlinx.serialization's conversions jsonStompSession . use { s -> s . convertAndSend ( \"/some/destination\" , Person ( \"Bob\" , 42 ), Person . serializer ()) // overloads without explicit serializers exist, but should be avoided if you also target JavaScript val messages : Flow < MyMessage > = s . subscribe ( \"/some/topic/destination\" , MyMessage . serializer ()) messages . collect { msg -> println ( \"Received message from ${ msg . author } : ${ msg . content } \" ) } } Custom Json instance \u00b6 The withJsonConversions() method takes an optional Json parameter, so you can configure it as you please: // custom Json configuration val json = Json { encodeDefaults = true ignoreUnknownKeys = true } val session = StompClient (). connect ( url ) val jsonStompSession = session . withJsonConversions ( json ) Dependency \u00b6 General case \u00b6 Krossbow's base Kotlinx Serialization module is format-agnostic, so you need to add both the krossbow-stomp-kxserialization dependency and the Kotlinx Serialization dependency for the format you want to use. For instance in the case of protobuf, that would be kotlinx-serialization-protobuf : implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:4.0.0\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-serialization-protobuf:1.3.3\" ) JSON format \u00b6 Since JSON is so common, Krossbow provides an all-in-one module with additional helpers for JSON: implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization-json:4.0.0\" ) This module brings kotlinx-serialization-json transitively, so you don't have to add it yourself. Note that Kotlinx Serialization also requires a compiler plugin to generate serializers for your @Serializable classes. See the Kotlinx Serialization doc for more information about this.","title":"Kotlinx Serialization"},{"location":"stomp/conversions/kx-serialization/#stomp-with-kotlinx-serialization","text":"Kotlinx Serialization is a multiplatform and multi-format serialization library provided by the Kotlin team. It is a popular choice for Kotlin multiplatform libraries especially because of its extensive support of Kotlin features. The krossbow-stomp-kxserialization module is an extension of krossbow-stomp-core that provides new APIs to send and receive properly typed classes, and automatically convert STOMP frame bodies by leveraging Kotlinx Serialization.","title":"STOMP with Kotlinx Serialization"},{"location":"stomp/conversions/kx-serialization/#a-note-on-json-format","text":"Since Kotlinx Serialization supports multiple formats with different dependencies, you have to add your own dependency to bring the format of your choice. However, since JSON is so popular, Krossbow comes with the krossbow-stomp-kxserialization-json module, which adds dedicated helpers for JSON and the necessary transitive dependency on the JSON format.","title":"A note on JSON format"},{"location":"stomp/conversions/kx-serialization/#basic-usage","text":"This module brings the following extension functions on StompSession : withBinaryConversions(format: BinaryFormat, mediaType: String) withTextConversions(format: StringFormat, mediaType: String) JSON convenience If you're using JSON, a dedicated withJsonConversions helper for JSON serialization is provided in the krossbow-stomp-serialization-json module. These helpers turn your StompSession into a StompSessionWithKxSerialization . This new session type has additional methods that use Kotlinx Serialization's serializers to serialize/deserialize your objects using the format of your choice (JSON, protobuf, etc.). You can for instance use convertAndSend and subscribe overloads with serializers like this: import org.hildan.krossbow.stomp.* import org.hildan.krossbow.stomp.conversions.kxserialization.* @Serializable data class Person ( val name : String , val age : Int ) @Serializable data class MyMessage ( val timestamp : Long , val author : String , val content : String ) val session = StompClient (). connect ( url ) val jsonStompSession = session . withJsonConversions () // adds convenience methods for kotlinx.serialization's conversions jsonStompSession . use { s -> s . convertAndSend ( \"/some/destination\" , Person ( \"Bob\" , 42 ), Person . serializer ()) // overloads without explicit serializers exist, but should be avoided if you also target JavaScript val messages : Flow < MyMessage > = s . subscribe ( \"/some/topic/destination\" , MyMessage . serializer ()) messages . collect { msg -> println ( \"Received message from ${ msg . author } : ${ msg . content } \" ) } }","title":"Basic usage"},{"location":"stomp/conversions/kx-serialization/#custom-json-instance","text":"The withJsonConversions() method takes an optional Json parameter, so you can configure it as you please: // custom Json configuration val json = Json { encodeDefaults = true ignoreUnknownKeys = true } val session = StompClient (). connect ( url ) val jsonStompSession = session . withJsonConversions ( json )","title":"Custom Json instance"},{"location":"stomp/conversions/kx-serialization/#dependency","text":"","title":"Dependency"},{"location":"stomp/conversions/kx-serialization/#general-case","text":"Krossbow's base Kotlinx Serialization module is format-agnostic, so you need to add both the krossbow-stomp-kxserialization dependency and the Kotlinx Serialization dependency for the format you want to use. For instance in the case of protobuf, that would be kotlinx-serialization-protobuf : implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization:4.0.0\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-serialization-protobuf:1.3.3\" )","title":"General case"},{"location":"stomp/conversions/kx-serialization/#json-format","text":"Since JSON is so common, Krossbow provides an all-in-one module with additional helpers for JSON: implementation ( \"org.hildan.krossbow:krossbow-stomp-kxserialization-json:4.0.0\" ) This module brings kotlinx-serialization-json transitively, so you don't have to add it yourself. Note that Kotlinx Serialization also requires a compiler plugin to generate serializers for your @Serializable classes. See the Kotlinx Serialization doc for more information about this.","title":"JSON format"},{"location":"stomp/conversions/moshi/","text":"STOMP with Moshi \u00b6 The krossbow-stomp-moshi module is a JVM-only extension of krossbow-stomp-core that provides new APIs to send and receive properly typed classes, and automatically convert them to/from the JSON bodies of STOMP frames by leveraging Moshi . The main addition is the extension function StompSession.withMoshi() , which turns your StompSession into a TypedStompSession . This new session type has additional methods that use Moshi to convert your objects into JSON and back: // example Moshi instance that converts Kotlin types using reflection val moshi = Moshi . Builder () . addLast ( KotlinJsonAdapterFactory ()) . build () StompClient (). connect ( url ). withMoshi ( moshi ). use { session -> session . convertAndSend ( \"/some/destination\" , Person ( \"Bob\" , 42 )) val messages : Flow < MyMessage > = session . subscribe < MyMessage > ( \"/some/topic/destination\" ) val firstMessage : MyMessage = messages . first () println ( \"Received: $ firstMessage \" ) } Dependency \u00b6 You will need to declare the following Gradle dependency to add these capabilities (you don't need the core module anymore as it is transitively brought by this one): implementation ( \"org.hildan.krossbow:krossbow-stomp-moshi:4.0.0\" ) This dependency transitively brings Moshi 1.13.0.","title":"Moshi"},{"location":"stomp/conversions/moshi/#stomp-with-moshi","text":"The krossbow-stomp-moshi module is a JVM-only extension of krossbow-stomp-core that provides new APIs to send and receive properly typed classes, and automatically convert them to/from the JSON bodies of STOMP frames by leveraging Moshi . The main addition is the extension function StompSession.withMoshi() , which turns your StompSession into a TypedStompSession . This new session type has additional methods that use Moshi to convert your objects into JSON and back: // example Moshi instance that converts Kotlin types using reflection val moshi = Moshi . Builder () . addLast ( KotlinJsonAdapterFactory ()) . build () StompClient (). connect ( url ). withMoshi ( moshi ). use { session -> session . convertAndSend ( \"/some/destination\" , Person ( \"Bob\" , 42 )) val messages : Flow < MyMessage > = session . subscribe < MyMessage > ( \"/some/topic/destination\" ) val firstMessage : MyMessage = messages . first () println ( \"Received: $ firstMessage \" ) }","title":"STOMP with Moshi"},{"location":"stomp/conversions/moshi/#dependency","text":"You will need to declare the following Gradle dependency to add these capabilities (you don't need the core module anymore as it is transitively brought by this one): implementation ( \"org.hildan.krossbow:krossbow-stomp-moshi:4.0.0\" ) This dependency transitively brings Moshi 1.13.0.","title":"Dependency"},{"location":"websocket/builtin/","text":"Krossbow Web Socket Built-in \u00b6 The krossbow-websocket-builtin module defines implementations of the WebSocketClient interface by adapting clients that already exist in each platform (without 3rd-party dependencies). For convenience in common source sets, this module also provides the default() factory method, which returns the built-in implementation of the current platform. JVM \u00b6 On the JVM target, the Jdk11WebSocketClient adapts the built-in HttpClient provided in the JRE since Java 11, and its WebSocket interface. JavaScript \u00b6 On the JS target, the BrowserWebSocketClient adapts the browser's built-in WebSocket directly. Also, the JsWebSocketClientAdapter allows to adapt anything that looks like the browser's WebSocket . Darwin (macOS, iOS, tvOS, watchOS) \u00b6 On all Darwin targets, the DarwinWebSocketClient adapts the Foundation framework's NSURLSessionWebSocketTask . Dependency information \u00b6 To use the built-in web socket client for pure web socket interactions, add the following to your build.gradle : implementation ( \"org.hildan.krossbow:krossbow-websocket-builtin:4.0.0\" ) If you're using STOMP with this default built-in client, you actually only need krossbow-stomp-default , which transitively brings krossbow-websocket-builtin : implementation ( \"org.hildan.krossbow:krossbow-stomp-default:4.0.0\" )","title":"Built-in"},{"location":"websocket/builtin/#krossbow-web-socket-built-in","text":"The krossbow-websocket-builtin module defines implementations of the WebSocketClient interface by adapting clients that already exist in each platform (without 3rd-party dependencies). For convenience in common source sets, this module also provides the default() factory method, which returns the built-in implementation of the current platform.","title":"Krossbow Web Socket Built-in"},{"location":"websocket/builtin/#jvm","text":"On the JVM target, the Jdk11WebSocketClient adapts the built-in HttpClient provided in the JRE since Java 11, and its WebSocket interface.","title":"JVM"},{"location":"websocket/builtin/#javascript","text":"On the JS target, the BrowserWebSocketClient adapts the browser's built-in WebSocket directly. Also, the JsWebSocketClientAdapter allows to adapt anything that looks like the browser's WebSocket .","title":"JavaScript"},{"location":"websocket/builtin/#darwin-macos-ios-tvos-watchos","text":"On all Darwin targets, the DarwinWebSocketClient adapts the Foundation framework's NSURLSessionWebSocketTask .","title":"Darwin (macOS, iOS, tvOS, watchOS)"},{"location":"websocket/builtin/#dependency-information","text":"To use the built-in web socket client for pure web socket interactions, add the following to your build.gradle : implementation ( \"org.hildan.krossbow:krossbow-websocket-builtin:4.0.0\" ) If you're using STOMP with this default built-in client, you actually only need krossbow-stomp-default , which transitively brings krossbow-websocket-builtin : implementation ( \"org.hildan.krossbow:krossbow-stomp-default:4.0.0\" )","title":"Dependency information"},{"location":"websocket/custom/","text":"Implement Krossbow's WebSocketClient yourself \u00b6 The krossbow-websocket-core module defines a standard web socket API abstraction that is used by the STOMP artifacts and that you can also use directly if you're only interested in the web socket protocol without STOMP. Krossbow provides built-in implementations of the web socket interfaces in the krossbow-websocket-builtin module , but you can of course implement your own. Basics \u00b6 You can create your own implementation of Krossbow's web socket client by implementing the WebSocketClient interface. This interface simply has a connect() method returning an instance of WebSocketConnection . The WebSocketConnection actually contains the bulk of the web socket interactions implementation. Please follow the KDoc of these interfaces to learn more about the contract that needs to be satisfied for each method. Helpers \u00b6 The krossbow-websocket-core module doesn't only provide interfaces to implement. It also provides some helper classes that help with most implementations of those interfaces. The WebSocketListenerFlowAdapter allows to adapt listener-based web socket APIs to Krossbow's Flow API easily. It takes care of partial message handling automatically, and can provide backpressure on the callback caller thanks to its suspend callbacks. The UnboundedWsListenerFlowAdapter also adapts listener-based APIs to Krossbow's flow, but without any backpressure support (functions are not suspend and return immediately). It adds new messages to an unbounded queue. This is necessary with some APIs like JS browsers WebSocket API, which cannot apply backpressure in any way on their web socket traffic. Dependency information \u00b6 Add the following to your build.gradle(.kts) in order to get the Krossbow's interfaces and helpers: implementation ( \"org.hildan.krossbow:krossbow-websocket-core:4.0.0\" )","title":"Implement your own"},{"location":"websocket/custom/#implement-krossbows-websocketclient-yourself","text":"The krossbow-websocket-core module defines a standard web socket API abstraction that is used by the STOMP artifacts and that you can also use directly if you're only interested in the web socket protocol without STOMP. Krossbow provides built-in implementations of the web socket interfaces in the krossbow-websocket-builtin module , but you can of course implement your own.","title":"Implement Krossbow's WebSocketClient yourself"},{"location":"websocket/custom/#basics","text":"You can create your own implementation of Krossbow's web socket client by implementing the WebSocketClient interface. This interface simply has a connect() method returning an instance of WebSocketConnection . The WebSocketConnection actually contains the bulk of the web socket interactions implementation. Please follow the KDoc of these interfaces to learn more about the contract that needs to be satisfied for each method.","title":"Basics"},{"location":"websocket/custom/#helpers","text":"The krossbow-websocket-core module doesn't only provide interfaces to implement. It also provides some helper classes that help with most implementations of those interfaces. The WebSocketListenerFlowAdapter allows to adapt listener-based web socket APIs to Krossbow's Flow API easily. It takes care of partial message handling automatically, and can provide backpressure on the callback caller thanks to its suspend callbacks. The UnboundedWsListenerFlowAdapter also adapts listener-based APIs to Krossbow's flow, but without any backpressure support (functions are not suspend and return immediately). It adds new messages to an unbounded queue. This is necessary with some APIs like JS browsers WebSocket API, which cannot apply backpressure in any way on their web socket traffic.","title":"Helpers"},{"location":"websocket/custom/#dependency-information","text":"Add the following to your build.gradle(.kts) in order to get the Krossbow's interfaces and helpers: implementation ( \"org.hildan.krossbow:krossbow-websocket-core:4.0.0\" )","title":"Dependency information"},{"location":"websocket/ktor/","text":"Krossbow with Ktor \u00b6 Krossbow allows you to use Ktor's web socket as transport for STOMP. Ktor's implementation supports a variety of platforms and is very popular in the Kotlin world, especially in Kotlin multiplatform. The krossbow-websocket-ktor module provides the KtorWebSocketClient , which adapts Ktor 2.0.2's HttpClient to Krossbow's web socket interface. Still stuck with Ktor 1.6? Not all projects can easily migrate to Ktor 2, that's why Krossbow provides the krossbow-websocket-ktor-legacy . Use that module instead of krossbow-websocket-ktor if you want to use Ktor 1.6.8's HttpClient . Usage with StompClient \u00b6 To use the KtorWebSocketClient instead of the platform default, you need to specify it when creating your StompClient : val client = StompClient ( KtorWebSocketClient ()) You can customize the actual Ktor HTTP client used behind the scenes by passing it to KtorWebSocketClient : // You may configure Ktor HTTP client as you please, // but make sure at least the websocket feature is installed val httpClient = HttpClient { install ( WebSockets ) } val wsClient = KtorWebSocketClient ( httpClient ) val stompClient = StompClient ( wsClient ) Dependency information \u00b6 You will need to declare the following Gradle dependency to use the KtorWebSocketClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:4.0.0\" ) Ktor uses pluggable engines to perform the platform-specific network operations (just like Krossbow uses different web socket implementations). You need to pick an engine that supports web sockets in order to use Ktor's HttpClient with web sockets. Follow Ktor's documentation to find out more about how to use engines. For instance, if you want to use Ktor's CIO engine with Krossbow, you need to declare the following: implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:4.0.0\" ) implementation ( \"io.ktor:ktor-client-cio:2.0.2\" ) If you want to use the older version 1.6.x of Ktor, use krossbow-websocket-ktor-legacy instead: implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor-legacy:4.0.0\" ) implementation ( \"io.ktor:ktor-client-cio:1.6.8\" )","title":"Ktor"},{"location":"websocket/ktor/#krossbow-with-ktor","text":"Krossbow allows you to use Ktor's web socket as transport for STOMP. Ktor's implementation supports a variety of platforms and is very popular in the Kotlin world, especially in Kotlin multiplatform. The krossbow-websocket-ktor module provides the KtorWebSocketClient , which adapts Ktor 2.0.2's HttpClient to Krossbow's web socket interface. Still stuck with Ktor 1.6? Not all projects can easily migrate to Ktor 2, that's why Krossbow provides the krossbow-websocket-ktor-legacy . Use that module instead of krossbow-websocket-ktor if you want to use Ktor 1.6.8's HttpClient .","title":"Krossbow with Ktor"},{"location":"websocket/ktor/#usage-with-stompclient","text":"To use the KtorWebSocketClient instead of the platform default, you need to specify it when creating your StompClient : val client = StompClient ( KtorWebSocketClient ()) You can customize the actual Ktor HTTP client used behind the scenes by passing it to KtorWebSocketClient : // You may configure Ktor HTTP client as you please, // but make sure at least the websocket feature is installed val httpClient = HttpClient { install ( WebSockets ) } val wsClient = KtorWebSocketClient ( httpClient ) val stompClient = StompClient ( wsClient )","title":"Usage with StompClient"},{"location":"websocket/ktor/#dependency-information","text":"You will need to declare the following Gradle dependency to use the KtorWebSocketClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:4.0.0\" ) Ktor uses pluggable engines to perform the platform-specific network operations (just like Krossbow uses different web socket implementations). You need to pick an engine that supports web sockets in order to use Ktor's HttpClient with web sockets. Follow Ktor's documentation to find out more about how to use engines. For instance, if you want to use Ktor's CIO engine with Krossbow, you need to declare the following: implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor:4.0.0\" ) implementation ( \"io.ktor:ktor-client-cio:2.0.2\" ) If you want to use the older version 1.6.x of Ktor, use krossbow-websocket-ktor-legacy instead: implementation ( \"org.hildan.krossbow:krossbow-websocket-ktor-legacy:4.0.0\" ) implementation ( \"io.ktor:ktor-client-cio:1.6.8\" )","title":"Dependency information"},{"location":"websocket/okhttp/","text":"Krossbow with OkHttp \u00b6 Krossbow allows you to use OkHttp's WebSocket as transport for STOMP. OkHttp is very popular on Android, and is already part of many projects as HTTP client of choice. The krossbow-websocket-okhttp module provides the OkHttpWebSocketClient , which adapts OkHttp's WebSocket to Krossbow's web socket interface. Usage with StompClient \u00b6 To use the OkHttpWebSocketClient instead of the platform default, you need to specify it when creating your StompClient : val client = StompClient ( OkHttpWebSocketClient ()) You can customize the actual OkHttpClient used behind the scenes by passing it to OkHttpWebSocketClient() : // This allows to configure the underlying OkHttpClient as you please // (or use an existing one from your project) val okHttpClient = OkHttpClient . Builder () . callTimeout ( Duration . ofMinutes ( 1 )) . pingInterval ( Duration . ofSeconds ( 10 )) . build () val wsClient = OkHttpWebSocketClient ( okHttpClient ) val stompClient = StompClient ( wsClient ) Dependency information \u00b6 You will need to declare the following Gradle dependency to use the OkHttpWebSocketClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-okhttp:4.0.0\" )","title":"OkHttp"},{"location":"websocket/okhttp/#krossbow-with-okhttp","text":"Krossbow allows you to use OkHttp's WebSocket as transport for STOMP. OkHttp is very popular on Android, and is already part of many projects as HTTP client of choice. The krossbow-websocket-okhttp module provides the OkHttpWebSocketClient , which adapts OkHttp's WebSocket to Krossbow's web socket interface.","title":"Krossbow with OkHttp"},{"location":"websocket/okhttp/#usage-with-stompclient","text":"To use the OkHttpWebSocketClient instead of the platform default, you need to specify it when creating your StompClient : val client = StompClient ( OkHttpWebSocketClient ()) You can customize the actual OkHttpClient used behind the scenes by passing it to OkHttpWebSocketClient() : // This allows to configure the underlying OkHttpClient as you please // (or use an existing one from your project) val okHttpClient = OkHttpClient . Builder () . callTimeout ( Duration . ofMinutes ( 1 )) . pingInterval ( Duration . ofSeconds ( 10 )) . build () val wsClient = OkHttpWebSocketClient ( okHttpClient ) val stompClient = StompClient ( wsClient )","title":"Usage with StompClient"},{"location":"websocket/okhttp/#dependency-information","text":"You will need to declare the following Gradle dependency to use the OkHttpWebSocketClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-okhttp:4.0.0\" )","title":"Dependency information"},{"location":"websocket/sockjs/","text":"Krossbow with SockJS \u00b6 Krossbow allows you to use SockJS-compatible clients as transport for STOMP. The krossbow-websocket-sockjs is a multiplatform facade implementing Krossbow's web socket interface by relying on different SockJS implementations. Here are the backing implementations for the different platforms: JS (browser and NodeJS): the sockjs-client library (isomorphic) JVM: Spring's WebSocketClient (with SockJS enabled), through krossbow-websocket-spring Using a SockJS client requires a SockJS-enabled server. Usage with StompClient \u00b6 To use this client, just call SockJSClient() and the relevant platform-specific client will be instantiated for you: val client = StompClient ( SockJSClient ()) Dependency information \u00b6 You will need to declare the following Gradle dependency to use the SockJSClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-sockjs:4.0.0\" )","title":"SockJS"},{"location":"websocket/sockjs/#krossbow-with-sockjs","text":"Krossbow allows you to use SockJS-compatible clients as transport for STOMP. The krossbow-websocket-sockjs is a multiplatform facade implementing Krossbow's web socket interface by relying on different SockJS implementations. Here are the backing implementations for the different platforms: JS (browser and NodeJS): the sockjs-client library (isomorphic) JVM: Spring's WebSocketClient (with SockJS enabled), through krossbow-websocket-spring Using a SockJS client requires a SockJS-enabled server.","title":"Krossbow with SockJS"},{"location":"websocket/sockjs/#usage-with-stompclient","text":"To use this client, just call SockJSClient() and the relevant platform-specific client will be instantiated for you: val client = StompClient ( SockJSClient ())","title":"Usage with StompClient"},{"location":"websocket/sockjs/#dependency-information","text":"You will need to declare the following Gradle dependency to use the SockJSClient : implementation ( \"org.hildan.krossbow:krossbow-websocket-sockjs:4.0.0\" )","title":"Dependency information"},{"location":"websocket/spring/","text":"Krossbow with Spring \u00b6 Krossbow allows you to use Spring's WebSocketClient as transport for STOMP. The krossbow-websocket-spring module provides the SpringWebSocketClientAdapter , which adapts any of Spring's WebSocketClient to Krossbow's web socket interface. On top of that, some pre-configured clients are provided: SpringDefaultWebSocketClient : based on the StandardWebSocketClient , which relies on the JSR-356 ( javax.websocket.* ) web socket standard. SpringSockJSWebSocketClient : an implementation using the SockJS protocol (requires a SockJS server), based on the standard web socket client, with the ability to fall back to other transports (like RestTemplateXhrTransport ). SpringJettyWebSocketClient : based on the JettyWebSocketClient (requires Jetty dependency, see below) Usage with StompClient \u00b6 Predefined clients \u00b6 To use one of the predefined Spring clients, you need to specify it when creating your StompClient : val stompClient = StompClient ( SpringDefaultWebSocketClient ) Or using the default SockJS client: val stompClient = StompClient ( SpringSockJSWebSocketClient ) Custom SpringWebSocketClient \u00b6 You can also use your own SpringWebSocketClient by wrapping it in a SpringWebSocketClientAdapter : // Pure Spring configuration val springWsClient = StandardWebSocketClient (). apply { taskExecutor = SimpleAsyncTaskExecutor ( \"my-websocket-threads\" ) userProperties = mapOf ( \"my-prop\" to \"someValue\" ) } // Krossbow adapter val stompClient = StompClient ( SpringWebSocketClientAdapter ( springWsClient )) Another example of custom client, using Spring's SockJS client: // Pure Spring configuration val transports = listOf ( WebSocketTransport ( StandardWebSocketClient ()), RestTemplateXhrTransport ( myCustomRestTemplate ), ) val sockJsClient = SockJsClient ( transports ) // Krossbow adapter val stompClient = StompClient ( SpringWebSocketClientAdapter ( sockJsClient )) Dependency information \u00b6 You will need to declare the following Gradle dependency to use the Spring adapters: implementation ( \"org.hildan.krossbow:krossbow-websocket-spring:4.0.0\" ) If you're using the SpringDefaultWebSocketClient (or SpringSockJSWebSocketClient with default settings), you'll need to add a dependency on a JSR-356 implementation, such as Tyrus: implementation ( \"org.glassfish.tyrus.bundles:tyrus-standalone-client-jdk:1.17\" ) If you're using the SpringJettyWebSocketClient , you'll need to add a dependency on Jetty's web socket client: implementation ( \"org.eclipse.jetty.websocket:websocket-client:9.4.46.v20220331\" )","title":"Spring"},{"location":"websocket/spring/#krossbow-with-spring","text":"Krossbow allows you to use Spring's WebSocketClient as transport for STOMP. The krossbow-websocket-spring module provides the SpringWebSocketClientAdapter , which adapts any of Spring's WebSocketClient to Krossbow's web socket interface. On top of that, some pre-configured clients are provided: SpringDefaultWebSocketClient : based on the StandardWebSocketClient , which relies on the JSR-356 ( javax.websocket.* ) web socket standard. SpringSockJSWebSocketClient : an implementation using the SockJS protocol (requires a SockJS server), based on the standard web socket client, with the ability to fall back to other transports (like RestTemplateXhrTransport ). SpringJettyWebSocketClient : based on the JettyWebSocketClient (requires Jetty dependency, see below)","title":"Krossbow with Spring"},{"location":"websocket/spring/#usage-with-stompclient","text":"","title":"Usage with StompClient"},{"location":"websocket/spring/#predefined-clients","text":"To use one of the predefined Spring clients, you need to specify it when creating your StompClient : val stompClient = StompClient ( SpringDefaultWebSocketClient ) Or using the default SockJS client: val stompClient = StompClient ( SpringSockJSWebSocketClient )","title":"Predefined clients"},{"location":"websocket/spring/#custom-springwebsocketclient","text":"You can also use your own SpringWebSocketClient by wrapping it in a SpringWebSocketClientAdapter : // Pure Spring configuration val springWsClient = StandardWebSocketClient (). apply { taskExecutor = SimpleAsyncTaskExecutor ( \"my-websocket-threads\" ) userProperties = mapOf ( \"my-prop\" to \"someValue\" ) } // Krossbow adapter val stompClient = StompClient ( SpringWebSocketClientAdapter ( springWsClient )) Another example of custom client, using Spring's SockJS client: // Pure Spring configuration val transports = listOf ( WebSocketTransport ( StandardWebSocketClient ()), RestTemplateXhrTransport ( myCustomRestTemplate ), ) val sockJsClient = SockJsClient ( transports ) // Krossbow adapter val stompClient = StompClient ( SpringWebSocketClientAdapter ( sockJsClient ))","title":"Custom SpringWebSocketClient"},{"location":"websocket/spring/#dependency-information","text":"You will need to declare the following Gradle dependency to use the Spring adapters: implementation ( \"org.hildan.krossbow:krossbow-websocket-spring:4.0.0\" ) If you're using the SpringDefaultWebSocketClient (or SpringSockJSWebSocketClient with default settings), you'll need to add a dependency on a JSR-356 implementation, such as Tyrus: implementation ( \"org.glassfish.tyrus.bundles:tyrus-standalone-client-jdk:1.17\" ) If you're using the SpringJettyWebSocketClient , you'll need to add a dependency on Jetty's web socket client: implementation ( \"org.eclipse.jetty.websocket:websocket-client:9.4.46.v20220331\" )","title":"Dependency information"}]}